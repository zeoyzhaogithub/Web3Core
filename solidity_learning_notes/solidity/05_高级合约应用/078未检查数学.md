# 未检查数学（Unchecked Math）

## 概念

在 Solidity 0.8.0 及以上版本中，算术运算默认启用溢出检查（例如加法、减法、乘法）。若发生溢出/下溢，交易会 revert。未检查数学通过 unchecked 块禁用溢出检查，提供以下特性：

- 显著降低 Gas 消耗（节省 20-40%）
- 允许安全场景下的显式溢出（如循环计数器、时间计算）
- 行为与 0.8 之前版本一致（溢出时自动截断）

## 核心功能

操作| 默认行为|  unchecked 行为
---|-------- | ------
加法 a + b | 溢出时 revert|  允许溢出（回绕）
减法 a - b | 下溢时 revert | 允许下溢（回绕）
乘法 a * b|  溢出时 revert | 允许溢出（回绕）
自增 i++|  溢出时 revert|  允许溢出（回绕）

## 实现步骤

确定安全边界：确保运算在可控范围内（如循环计数器不会超过 type(uint).max）。

包裹代码块：用 unchecked { ... } 包裹目标运算。

隔离高风险操作：仅将确定安全的运算放入 unchecked 块。

## 完整合约代码示例

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract UncheckedMathDemo {
    // 示例 1: 安全的循环计数器
    function sum(uint n) public pure returns (uint) {
        uint total = 0;
        unchecked { // 确保 n 较小，避免溢出
            for (uint i = 0; i < n; i++) { // i++ 无检查
                total += i; // 加法需单独确保安全
            }
        }
        return total;
    }

    // 示例 2: 时间差计算（确保结束时间 > 开始时间）
    function timeElapsed(uint start, uint end) public pure returns (uint) {
        unchecked {
            return end - start; // 显式下溢安全
        }
    }

    // 示例 3: 批量转账优化
    function batchTransfer(address[] calldata recipients, uint[] calldata amounts) public {
        unchecked {
            for (uint i = 0; i < recipients.length; i++) { // 节省循环 Gas
                // 实际转账逻辑（略）
            }
        }
    }

    // 示例 4: 显式溢出（密码学场景）
    function modularIncrement(uint x, uint mod) public pure returns (uint) {
        unchecked {
            return (x + 1) % mod; // 依赖溢出回绕
        }
    }
}
```

## 关键功能说明

### Gas 优化

```solidity
// 默认检查：消耗约 30 Gas
// 未检查：消耗约 3 Gas（节省 90%）
unchecked { i++; }
```

### 安全边界控制

```solidity
function safeAdd(uint a, uint b) public pure returns (uint) {
    if (a > type(uint).max - b) revert Overflow();
    unchecked { return a + b; } // 手动检查后使用
}
```

### 循环优化

```solidity
for (uint i = 0; i < 100; ) {
    // ... 逻辑 ...
    unchecked { i++; } // 推荐将 i++ 放在循环末尾
}
```

### 时间计算（天然安全）

```solidity
unchecked {
    uint elapsed = block.timestamp - lastUpdated; // 时间不会下溢
}
```

## 最佳实践

严格限制范围：确保输入值在预期范围内（如使用 require(n < 1000)）。

避免嵌套：unchecked 块尽量小巧，减少意外覆盖。

单元测试：对边界值（0, max, max+1）进行全面测试。

文档注释：明确说明为何此处可安全禁用检查。

⚠️ 警告：错误使用 unchecked 会导致资金漏洞（如著名的 SteakHut 漏洞，损失 35 万美元）。仅在100%确定安全时使用！
