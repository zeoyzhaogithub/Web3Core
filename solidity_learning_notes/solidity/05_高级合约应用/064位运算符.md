# 位运算符 Bitwise Operators

Solidity 提供了一系列位运算符，用于在二进制级别直接操作整数类型（int/uint）。以下是完整的运算符列表、使用说明、场景及实例代码：

## 位运算符列表

运算符| 名称 |描述
| --- | --- | --- |
& |按位与| 两个位都为1时结果为1
\| |按位或 |任意一位为1时结果为1
^ |按位异或| 两个位不同时结果为1
~ |按位取反| 翻转所有位（0变1，1变0）
<<| 左移| 将位向左移动，右侧补0
\>> |右移| 将位向右移动（逻辑/算术右移）

注意：uint 使用逻辑右移（补0），int 使用算术右移（保留符号位）。

## 使用场景

节省 Gas：打包多个布尔值到单个变量中（替代多个 bool）

权限控制：用位掩码管理多角色权限

高效存储：存储紧凑型数据（如 RGB 颜色、IP 地址）

加密算法：实现底层位操作（如 SHA, XOR 加密）

数学优化：快速乘除（<<1 等效乘2，>>1 等效除2）

## 完整实例代码

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract BitwiseOperations {
    // 场景1：权限管理（用位掩码表示角色）
    uint8 public constant ADMIN = 1 << 0; // 00000001 (1)
    uint8 public constant EDITOR = 1 << 1; // 00000010 (2)
    uint8 public constant VIEWER = 1 << 2; // 00000100 (4)

    mapping(address => uint8) public roles;

    // 授予角色（按位或）
    function grantRole(address user, uint8 role) public {
        roles[user] |= role; // 添加角色不覆盖现有权限
    }

    // 撤销角色（按位与 + 取反）
    function revokeRole(address user, uint8 role) public {
        roles[user] &= ~role; // 只关闭特定位
    }

    // 检查角色（按位与）
    function hasRole(address user, uint8 role) public view returns (bool) {
        return (roles[user] & role) != 0;
    }

    // 场景2：打包多个布尔值到 uint256
    uint256 public packedFlags;

    // 设置标志位（index: 0~255）
    function setFlag(uint8 index, bool value) public {
        if (value) {
            packedFlags |= (1 << index); // 置位
        } else {
            packedFlags &= ~(1 << index); // 清零
        }
    }

    // 读取标志位
    function getFlag(uint8 index) public view returns (bool) {
        return (packedFlags & (1 << index)) != 0;
    }

    // 场景3：高效计算（左移/右移）
    function multiplyByPowerOfTwo(uint256 x, uint256 n) public pure returns (uint256) {
        return x << n; // 等效 x * 2^n
    }

    function divideByPowerOfTwo(uint256 x, uint256 n) public pure returns (uint256) {
        return x >> n; // 等效 x / 2^n (整数除法)
    }

    // 场景4：按位异或加密
    function xorEncrypt(uint256 data, uint256 key) public pure returns (uint256) {
        return data ^ key; // 简单异或加密
    }
}

```

## 关键操作详解

### 1. 权限控制

授权: roles |= role → 添加角色

撤权: roles &= ~role → 移除角色

检查: (roles & role) != 0 → 是否拥有角色

### 2. 布尔值打包

设置位: flags |= (1 << index) → 设为 true

清除位: flags &= ~(1 << index) → 设为 false

读取位: (flags & (1 << index)) != 0 → 检查状态

### 3. 移位运算

快速乘法: x << n = x × 2nx×2n

快速除法: x >> n = x÷2nx÷2n（整数除法）

## 注意事项

溢出风险：移位时确保不超过类型范围（如 uint8 << 10 会归零）。

符号处理：右移 int 时保留符号位（-8 >> 1 = -4）。

Gas 优化：位运算比布尔数组更省 Gas（单次操作处理256个标志位）。

通过位运算符，可显著提升合约在权限管理、状态压缩和数学运算上的效率。

---------

## Bitwise Operators

1. AND 运算符
• 功能：当两个输⼊位都为1时，输出1；否则输出0。
• ⽰例：如果 x = 14 (⼆进制1110) 和 y = 11 (⼆进制1011)，使⽤ AND 运算得到10 (⼆进制1010)。
2. OR 运算符
• 功能：当⾄少⼀个输⼊位为1时，输出1。
• ⽰例：如果 x = 12 (⼆进制1100) 和 y = 9 (⼆进制1001)，使⽤ OR 运算得到13 (⼆进制1101)。
3. XOR 运算符
• 功能：当且仅当⼀个输⼊位为1时，输出1。
• ⽰例：如果 x = 12 (⼆进制1100) 和 y = 5 (⼆进制0101)，使⽤ XOR 运算得到9 (⼆进制1001)。
4. NOT 运算符
• 功能：反转位，即1变0，0变1。
• ⽰例：如果 x = 12 (⼆进制00001100)，使⽤ NOT 运算后结果为243 (⼆进制11110011)。
5. Shift Left 运算符
• 功能：向左移位。
• ⽰例：将3 (⼆进制0011) 向左移两位得到12 (⼆进制1100)。
6. Shift Right 运算符
• 功能：向右移位。
• ⽰例：将12 (⼆进制1100) 向右移⼀位得到6 (⼆进制0110)。

```solidity
// SPDX-License-Identifier: MIT
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;
contract BitwiseOps {
// x = 1110 = 8 + 4 + 2 + 0 = 14
// y = 1011 = 8 + 0 + 2 + 1 = 11
// x & y = 1010 = 8 + 0 * 2 + 0 = 10
function and(uint256 x, uint256 y) external pure returns (uint256) {
return x & y;
}
// x = 1100 = 8 + 4 + 0 + 0 = 12
// y = 1001 = 8 + 0 + 0 + 1 = 9
// x | y = 1101 = 8 + 4 + 0 + 1 = 13
function or(uint256 x, uint256 y) external pure returns (uint256) {
return x | y;
}
// x = 1100 = 8 + 4 + 0 + 0 = 12
// y = 0101 = 0 + 4 + 0 + 1 = 5
// x ^ y = 1001 = 8 + 0 + 0 + 1 = 9
function xor(uint256 x, uint256 y) external pure returns (uint256) {
return x ^ y;
}
// x = 00001100 = 0 + 0 + 0 + 0 + 8 + 4 + 0 + 0 = 12
// ~x = 11110011 = 128 + 64 + 32 + 16 + 0 + 0 + 2 + 1 = 243
function not(uint8 x) external pure returns (uint8) {
return ~x;
}
// 1 << 0 = 0001 --> 0001 = 1
// 1 << 1 = 0001 --> 0010 = 2
// 1 << 2 = 0001 --> 0100 = 4
// 1 << 3 = 0001 --> 1000 = 8
// 3 << 2 = 0011 --> 1100 = 12
function shiftLeft(uint256 x, uint256 bits)
external
pure
returns (uint256)
{
return x << bits;
}
// 8 >> 0 = 1000 --> 1000 = 8
// 8 >> 1 = 1000 --> 0100 = 4
// 8 >> 2 = 1000 --> 0010 = 2
// 8 >> 3 = 1000 --> 0001 = 1
// 8 >> 4 = 1000 --> 0000 = 0
// 12 >> 1 = 1100 --> 0110 = 6
function shiftRight(uint256 x, uint256 bits)
external
pure
returns (uint256)
{
return x >> bits;
}
// Get last n bits from x
// Example, last 3 bits
// x = 1101 = 13
// mask = 0111
// output = 0101 = 4 + 1 =5
function getLastNBits(uint256 x, uint256 n)
external
pure
returns (uint256)
{
// 1 --> 1000 - 1 -> 0111
uint mask = (1 << n) - 1;
return x & mask;
}
function getLastNBitUsingMod(uint x, uint n) external pure
returns(uint256) {
return x % (1 << n);
}
}
```
