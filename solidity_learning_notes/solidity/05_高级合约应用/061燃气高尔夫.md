# 燃气高尔夫（Gas Golfing）

## 概念

燃气高尔夫是 Solidity 开发中的一种优化技术，旨在通过最小化智能合约的 燃气消耗（Gas Cost） 来降低用户执行交易的成本。其核心原则包括：

减少存储操作（SSTORE/SLOAD 是最高成本操作之一）。
优化计算逻辑（避免循环、使用位运算替代算术）。
精简字节码（减少合约部署成本）。
利用 EVM 特性（如短路评估、内联汇编）。

## 关键功能

### 燃气高效的数据存储

使用 packed storage（将多个变量打包到单个存储槽）。

优先使用 memory 或 calldata 替代 storage。

### 计算优化

用位运算（如 <<, >>, &, |）替代乘除法。

避免循环（尤其是动态长度数组的循环）。

### 字节码精简

使用 external 而非 public 函数（避免参数拷贝）。

删除未使用的代码和变量。

### 内联汇编（Assembly）

手动优化 EVM 操作码（如直接操作存储槽）。

## 实现步骤

### 分析燃气热点

使用工具（如 Hardhat Gas Reporter、Remix Gas Profiler）识别高耗燃气函数。

### 优化数据布局

将多个 uint 变量合并到一个存储槽（例如：uint128 a; uint128 b;）。

### 替换高成本操作

用 != 0 替代 > 0（更便宜的 EVM 指令）。

用三元运算符 ? : 替代 if/else。

### 使用内联汇编

直接读写存储槽，避免 Solidity 的抽象开销。

### 测试与验证

对比优化前后的燃气消耗，确保功能正确性。

## 具体流程示例：优化一个计数器合约

### 原始合约（高燃气消耗）

```solidity
contract Counter {
    uint256 public count;
    uint256 public lastExecutor;

    function increment() public {
        count++;
        lastExecutor = block.timestamp;
    }
}
```

### 问题

每次调用修改两个存储变量（2 个 SSTORE = 约 10,000 ~ 20,000 Gas）。

### 优化步骤

#### 变量打包

将 count 和 lastExecutor 合并到同一存储槽：

```solidity
uint256 private packedData; // 高位: count, 低位: timestamp
```

#### 位运算操作

使用位移和掩码读写数据：

```solidity
function increment() external {
    uint256 packed = packedData;
    uint256 count = (packed >> 128) + 1;
    uint256 timestamp = block.timestamp;
    packedData = (count << 128) | (timestamp & 0xFFFFFFFFFFFFFFFF);
}
```

#### 内联汇编优化

直接操作存储槽（避免 Solidity 的语法开销）：

```solidity
function increment() external {
    assembly {
        let slot := sload(packedData.slot)
        let count := add(shr(128, slot), 1)
        let newData := or(shl(128, count), timestamp())
        sstore(packedData.slot, newData)
    }
}
```

### 完整优化合约代码

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract GasOptimizedCounter {
    // 存储槽 0: 高位 128 bits = count, 低位 128 bits = timestamp
    uint256 private packedData;

    function increment() external {
        assembly {
            // 读取存储槽 0
            let slot := sload(0)
            // 提取 count (高位 128 bits) 并 +1
            let count := add(shr(128, slot), 1)
            // 获取当前时间戳（仅用低 128 bits）
            let newTimestamp := timestamp()
            // 合并 count 和 timestamp
            let newData := or(shl(128, count), newTimestamp)
            // 写回存储
            sstore(0, newData)
        }
    }

    // 解码 packedData
    function getData() external view returns (uint256 count, uint256 timestamp) {
        uint256 packed = packedData;
        count = packed >> 128;
        timestamp = packed & 0xFFFFFFFFFFFFFFFF;
    }
}
```

### 关键优化点说明

#### 单存储槽操作

原本需要 2 次 SSTORE（~20,000 Gas），现在只需 1 次（~5,000 Gas）。

#### 内联汇编优势

避免 Solidity 的语法检查，直接使用 sload/sstore 操作码。

#### 位运算技巧

shr(128, slot)：右移 128 位获取 count。

or(shl(128, count), newTimestamp)：将新值合并。

#### 时间戳截断

时间戳用 128 位存储（0xFFFFFFFFFFFFFFFF 是 64 位掩码，但 EVM 时间戳实际为 64 位）。

### 燃气节省对比

操作 |原始合约 |优化后合约
|-|-|-|
increment()| ~42,000 Gas| ~21,000 Gas
节省| - |~50%

测试工具：使用 Remix Gas Profiler 或 Hardhat Gas Reporter 验证。

## 最佳实践

### 优先使用 unchecked

在安全区域禁用溢出检查（例如：unchecked { count++; }）。

### 避免动态数组循环

改用映射（mapping）或固定数组。

### 常量用 immutable/constant

减少部署和读取成本。

### 函数可见性

用 external 替代 public 避免内存拷贝。

通过燃气高尔夫，开发者能显著提升合约的经济性和用户体验，尤其在高频交易场景（如 DeFi、链游）中至关重要。
