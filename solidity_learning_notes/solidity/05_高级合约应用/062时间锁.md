# 时间锁（Timelock）

## 概念

时间锁（Timelock）是一种智能合约机制，延迟关键操作的执行。它要求提案在生效前必须经过一段等待期（如 24 小时），为社区提供审查和反应时间，防止恶意或错误操作。

## 核心功能

延迟执行：强制操作在队列中等待固定时间。

权限控制：仅允许特定地址（如治理合约）提交提案。

交易取消：在等待期内允许授权地址取消提案。

安全性：防止闪电治理攻击和紧急权限滥用。

## 实现步骤 & 流程

### 1. 提交提案

- 授权地址调用 queueTransaction，提供：

  - target：目标合约地址
  - value：发送的 ETH 数量
  - signature：函数签名（如 "transfer(address,uint256)"）
  - data：调用参数（ABI 编码）

合约计算执行时间戳 eta = block.timestamp + delay

### 2. 等待期

交易进入队列，倒计时开始。
用户可审查提案细节。
授权地址可调用 cancelTransaction 取消提案。

### 3. 执行提案

- 等待期结束后，授权地址调用 executeTransaction。
- 合约验证：
  - 当前时间 ≥ eta
  - 提案未被取消
  - 提案存在队列中
- 执行目标合约调用。

## 关键功能代码说明

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Timelock {
    event QueueTransaction(
        bytes32 indexed txHash,
        address indexed target,
        uint256 value,
        string signature,
        bytes data,
        uint256 eta
    );

    event ExecuteTransaction(bytes32 indexed txHash);
    event CancelTransaction(bytes32 indexed txHash);

    address public admin; // 治理合约地址
    uint256 public constant delay = 24 hours; // 固定延迟

    mapping(bytes32 => bool) public queuedTransactions;

    modifier onlyAdmin() {
        require(msg.sender == admin, "Unauthorized");
        _;
    }

    constructor(address admin_) {
        admin = admin_;
    }

    // 计算唯一交易哈希
    function getTxHash(
        address target,
        uint256 value,
        string memory signature,
        bytes memory data,
        uint256 eta
    ) public pure returns (bytes32) {
        return keccak256(abi.encode(target, value, signature, data, eta));
    }

    // 提交提案到队列
    function queueTransaction(
        address target,
        uint256 value,
        string memory signature,
        bytes memory data,
        uint256 eta
    ) external onlyAdmin {
        require(eta >= block.timestamp + delay, "ETA too early");
        
        bytes32 txHash = getTxHash(target, value, signature, data, eta);
        queuedTransactions[txHash] = true;
        
        emit QueueTransaction(txHash, target, value, signature, data, eta);
    }

    // 执行提案
    function executeTransaction(
        address target,
        uint256 value,
        string memory signature,
        bytes memory data,
        uint256 eta
    ) external payable onlyAdmin {
        require(block.timestamp >= eta, "Wait delay period");
        
        bytes32 txHash = getTxHash(target, value, signature, data, eta);
        require(queuedTransactions[txHash], "Not queued");
        
        queuedTransactions[txHash] = false;
        
        // 构建调用数据
        bytes memory callData;
        if (bytes(signature).length == 0) {
            callData = data;
        } else {
            callData = abi.encodePacked(
                bytes4(keccak256(bytes(signature))),
                data
            );
        }

        (bool success, ) = target.call{value: value}(callData);
        require(success, "Call failed");
        
        emit ExecuteTransaction(txHash);
    }

    // 取消提案
    function cancelTransaction(
        address target,
        uint256 value,
        string memory signature,
        bytes memory data,
        uint256 eta
    ) external onlyAdmin {
        bytes32 txHash = getTxHash(target, value, signature, data, eta);
        require(queuedTransactions[txHash], "Not queued");
        
        queuedTransactions[txHash] = false;
        emit CancelTransaction(txHash);
    }
}
```

## 关键点解析

### 唯一交易标识

getTxHash 使用所有参数生成唯一哈希，确保提案不可篡改。

### ABI 调用构造

executeTransaction 动态构建 calldata：

- 若提供 signature，则拼接函数选择器。
- 若为空，则直接使用 data（适用于 fallback 函数）。

### 安全验证

- queueTransaction：检查 eta >= 当前时间 + delay。
- executeTransaction：验证等待期已过且提案存在。

### 权限隔离

仅 admin（通常为 DAO 治理合约）可操作关键函数。

## 使用场景

DAO 治理：延迟执行资金转移或参数修改。
多签钱包：联合签名后进入等待期。
合约升级：给用户时间退出有风险的新版本。

注意：实际项目（如 Uniswap）会扩展功能，如最小延迟调整、批量操作等。此示例为核心逻辑的精简实现。
