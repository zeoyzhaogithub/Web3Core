# ERC721

3. ERC721合约的实现
• 合约的基本结构
• 事件声明：Transfer, Approval, ApprovalForAll
• 状态变量声明：
◦ 存储每个NFT的拥有者： mapping(uint => address) _owner
◦ 存储每个地址拥有的NFT数量： mapping(address => uint)_balance
◦ 存储NFT的批准地址： mapping(uint => address) _approvals
◦ 存储地址对所有NFT的批准： mapping(address => mapping(address => bool))
_isApprovedForAll
4. 函数实现
• supportsInterface 函数
• balanceOf 函数
• ownerOf 函数
• setApprovalForAll 函数
• approve 函数
• getApproved 函数
• 内部函数： _isApprovedOrOwner
• transferFrom 函数
• safeTransferFrom 函数（包括带数据参数的版本）
5. 辅助功能
• 铸造函数（mint）
• 销毁函数（burn）

```solidity
 // SPDX-License-Identifier: MIT
 pragma solidity 0.8.23;

 interface IERC165 {
 function supportsInterface(bytes4 interfaceID)
 external
 view
 returns (bool);
 }

 interface IERC721 is IERC165 {
 function balanceOf(address owner) external view returns (uint256 balance);
 function ownerOf(uint256 tokenId) external view returns (address owner);
 function safeTransferFrom(address from, address to, uint256 tokenId)
 external;
 function safeTransferFrom(
 address from,
 address to,
 uint256 tokenId,
 bytes calldata data
 ) external;
 function transferFrom(address from, address to, uint256 tokenId) external;
 function approve(address to, uint256 tokenId) external;
 function getApproved(uint256 tokenId)
 external
 view
 returns (address operator);
 function setApprovalForAll(address operator, bool _approved) external;
 function isApprovedForAll(address owner, address operator)
 external
 view
 returns (bool);
 }

 interface IERC721Receiver {
 function onERC721Received(
 address operator,
 address from,
 uint256 tokenId,
 bytes calldata data
 ) external returns (bytes4);
 }

 contract ERC721 is IERC721 {
 event Transfer(
 address indexed from, address indexed to, uint256 indexed id
 );
 event Approval(
 address indexed owner, address indexed spender, uint256 indexed id
 );
 event ApprovalForAll(
 address indexed owner, address indexed operator, bool approved
 );

 mapping (uint => address) internal_ownerOf;
 mapping(address => uint) internal _balanceOf;
 mapping(uint => address) internal_approvals;
 mapping(address => mapping(address => bool)) public isApprovedForAll;

 function supportsInterface(bytes4 interfaceID)
 external
 view
 returns (bool){
 return interfaceID == type(IERC721).interfaceId || interfaceID ==
type(IERC165).interfaceId;
 }

 function balanceOf(address owner) external view returns (uint256 balance){
 require(owner != address(0), "owner = address 0");
 return _balanceOf[owner];
 }

 function ownerOf(uint256 tokenId) external view returns (address owner){
 owner =_ownerOf[tokenId];
 require(owner != address(0), "owner = address 0");
 }
 function setApprovalForAll(address operator, bool _approved) external{
 isApprovedForAll[msg.sender][operator] =_approved;
 emit ApprovalForAll(msg.sender, operator, _approved);
 }

 function approve(address to, uint256 tokenId) external{
 address owner =_ownerOf[tokenId];
 require(
 msg.sender == owner || isApprovedForAll[owner][msg.sender],
 "not authorized"
 );
 _approvals[tokenId] = to;
 emit Approval(owner, to, tokenId);
 }
 function getApproved(uint256 tokenId)
 external
 view
93 returns (address operator){
94 require(_ownerOf[tokenId] != address(0), "tokenId not exist");
95 return _approvals[tokenId];
96 }
97
98 function_isApprovedOrOwner(
99 address owner,
100 address spender,
101 uint tokenId
102 ) internal view returns(bool) {
103 return (spender == owner
104 || isApprovedForAll[owner][spender]
105 || spender == _approvals[tokenId]
106 );
107 }
108
109 function transferFrom(address from, address to, uint256 tokenId) public {
110 require(from ==_ownerOf[tokenId], " from != owner");
111 require(to != address(0), "to = zero address");
112 require(_isApprovedOrOwner(from, msg.sender, tokenId), "not
authrized");
113
114_balanceOf[from] -- ;
115 _balanceOf[to] ++;
116_ownerOf[tokenId] = to;
117
118 delete _approvals[tokenId];
119 emit Transfer(from, to, tokenId);
120 }

123 function safeTransferFrom(address from, address to, uint256 tokenId)
124 external{
125 transferFrom(from, to, tokenId);

127 require(
128 to.code.length == 0 ||
IERC721Receiver(to).onERC721Received(msg.sender, from, tokenId, "") ==
IERC721Receiver.onERC721Received.selector, "unsafe recipient");
129 }

131 function safeTransferFrom(
132 address from,
133 address to,
134 uint256 tokenId,
135 bytes calldata data
136 ) external {
137 transferFrom(from, to, tokenId);
138 require(
139 to.code.length == 0 ||
IERC721Receiver(to).onERC721Received(msg.sender, from, tokenId, data) ==
IERC721Receiver.onERC721Received.selector, "unsafe recipient");
140 }
141
142 function_mint(address to, uint tokenId) internal {
143 require(to != address(0), "to = zero address");
144 require(_ownerOf[tokenId] == address(0), "token exists");
145
146_balanceOf[to] ++;
147 _ownerOf[tokenId] = to;
148 emit Transfer(address(0), to, tokenId);
149 }
150
151 function_burn(uint tokenId) internal {
152 address owner = _ownerOf[tokenId];
153 require(owner != address(0), "token does not exist");
154
155_balanceOf[owner]--;
156 delete _ownerOf[tokenId];
157 delete_approvals[tokenId];
158
159 emit Transfer(owner, address(0), tokenId);
160 }
161
162
163 }
164
165 contract MyNFT is ERC721 {
166 function mint(address to, uint tokenId) external {
167 _mint(to, tokenId);
168 }
169
170 function burn(uint tokenId) external {
171 require(msg.sender ==_ownerOf[tokenId], "not owner");
172 _burn(tokenId);
173 }
}
```
