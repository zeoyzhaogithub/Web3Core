# 使用二分搜索找到最显著位（MSB）

## 概念

最显著位（Most Significant Bit, MSB） 是一个二进制数中最高位的 1 所在的位置（从 0 开始计数）。例如：

- 5（二进制 101）的 MSB 是第 2 位（值为 4）。
- 128（二进制 10000000）的 MSB 是第 7 位。

在 Solidity 中高效计算 MSB 至关重要，因为 Gas 消耗直接影响合约执行成本。二分搜索（时间复杂度 O(log n)）比线性扫描更高效，尤其对 uint256（256 位）类型。

## 功能

输入：任意 uint256 值。

输出：MSB 的位置（0 到 255）。若输入为 0，返回 0。

核心优势：仅需最多 8 次循环（log2(256) = 8），Gas 消耗低且稳定。

## 实现步骤

### 处理边界情况：若输入为 0，直接返回 0

### 初始化指针

- low = 0（搜索起点）
- high = 255（搜索终点）

### 二分搜索循环

- 计算中点 mid = (low + high) / 2。
- 生成掩码：从 mid 位到 255 位全为 1 的比特掩码。
- 检查输入值在 [mid, 255] 区间是否有 1：
  - 若有：更新 result = mid，并将搜索下限设为 mid + 1。
  - 若无：将搜索上限设为 mid - 1。

### 返回结果

循环结束时，result 即为 MSB 位置。

## 关键功能说明

### 掩码生成

```solidity
uint256 mask = ~((1 << mid) - 1);
```

- (1 << mid) - 1：生成 0 到 mid-1 位全 1 的掩码。
- ~：按位取反，得到 mid 到 255 位全 1 的掩码。
- 示例：mid = 3 → 掩码为 0xFF...F8（第 3 位及以上为 1）。

### 区间检查

```solidity
if (x & mask != 0) { ... }
```

- 检测输入 x 在 [mid, 255] 区间是否存在 1。

### 指针更新

- 若高位区间存在 1：说明 MSB 在 [mid, 255] 内，更新 result = mid 并缩小搜索范围到 [mid + 1, high]。
- 否则：MSB 在 [0, mid - 1] 内，缩小搜索范围到 [low, mid - 1]。

## 完整合约代码

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract MSBFinder {
    /**
     *使用二分搜索查找输入值的 MSB 位置
     * @param x 输入的 uint256 值
     *@return msb MSB 位置（0 到 255），若输入为 0 则返回 0
     */
    function findMSB(uint256 x) public pure returns (uint8 msb) {
        if (x == 0) return 0;

        uint8 low = 0;
        uint8 high = 255;
        uint8 result = 0;

        while (low <= high) {
            uint8 mid = (low + high) >> 1; // 位运算优化：除以 2
            
            // 生成从 mid 位到 255 位全为 1 的掩码
            uint256 mask = ~((1 << mid) - 1);
            
            if (x & mask != 0) {
                result = mid;   // 记录当前 mid 作为候选结果
                low = mid + 1;  // 在更高区间继续搜索
            } else {
                high = mid - 1; // 在更低区间搜索
            }
        }
        
        return result;
    }
}
```

## 测试用例

输入 0：返回 0。

输入 1（0b000...1）：返回 0（第 0 位）。

输入 128（0b10000000）：返回 7。

输入 129（0b10000001）：返回 7。

输入 2^255（第 255 位为 1）：返回 255。

## 优势

高效：最多 8 次循环完成搜索。
安全：兼容 Solidity 0.8.x 的溢出检查。
Gas 优化：使用位运算（如 >> 1 代替除法）减少计算成本。

此实现是智能合约中处理位运算的高效标准方法，适用于需要快速定位最高位 1 的场景（如数值范围计算、位压缩算法等）。

---

## Most Significant Bit using Binary

Search Code
如何使⽤⼆分查找法在Solidity 0.8中编写函数，以寻找⼀个数字的最⾼有效位
（MSB）。我们将使⽤ uint256 类型的变量，探索如何通过逐步迭代减⼩搜索范围来定位最左边的
位。

1. 函数定义：
◦ 创建⼀个名为 findMostSignificantBit 的外部纯函数。
◦ 输⼊参数为 uint256 x ，代表要查找其最⾼有效位的数字。
2. 核⼼概念：
◦ uint256 表⽰的是⼀个256位的数字，最⼤索引位为255。
◦ 返回类型为 uint8 ，能够表⽰从0到255的数字。
3. ⼆分查找实现：
◦ 初始化判断 x 是否⼤于或等于 2^128 ，然后逐步减半，检查 2^64 ， 2^32 ， 2^16 ，
2^8 ， 2^4 ， 2^2 ，直到 2^1 。
◦ 根据条件判断结果，右移 x 并更新索引累加器 r 。
4. ⽰例与测试：
◦ 编译智能合约并部署。
◦ 通过实际输⼊测试函数，例如输⼊8（ 2^3 ），预期返回最⾼有效位3。

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.24;
contract MostSignificantBit{
// 10101010 -> 7
function findMostSignificantBit(uint256 x) external pure returns(uint8 r){
// x >= 2 **128
if ( x >= 2** 128){
x >>=128;
r+= 128;
}
// x >= 2 **64
if (x >= 2** 64){
x >>= 64;
r += 64;
}
// x >= 2 **32
if (x >= 2** 32){
x >>= 32;
r += 32;
}
// x >= 2 **16
if (x >= 2** 16){
x >>= 16;
r += 16;
}
// x >= 2 **8
if (x >= 2** 8){
x >>= 8;
r += 8;
}
// x >= 2 **4
if (x >= 2** 4){
x >>= 4;
r += 4;
}
// x >= 2 **2
if (x >= 2** 2){
x >>= 2;
 r += 2;
}
// x >= 2 ** 1
if (x >= 2){
 r += 1;
 }
}
}

```
