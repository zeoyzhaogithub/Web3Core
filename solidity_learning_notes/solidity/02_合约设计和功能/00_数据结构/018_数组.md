# 数组

在Solidity中，数组是一种非常重要的数据结构，用于存储相同类型元素的集合。数组可以是固定大小的，也可以是动态大小的。

## 1. 数组的类型

### 固定大小数组

固定大小数组在声明时需要指定长度(编译时确定)，一旦创建，长度不可改变。

```solidity

// 声明一个长度为5的uint类型数组

uint[5] fixedArray;

```

### 动态大小数组

动态数组的长度在声明时不确定，可以在运行时动态改变（通过`push`、`pop`等操作）。

```solidity

// 声明一个动态大小的uint类型数组

uint[] dynamicArray;

```

## 2. 数组的声明和初始化

### 声明

数组可以在状态变量、函数内部（作为存储引用或内存数组）中声明。

```solidity

// 状态变量

uint[] public arr; // 动态数组

uint[5] public fixedArr; // 固定数组

// 函数内部

function foo() public {

// 内存中的动态数组，必须指定长度（除非用字面量初始化）

uint[] memory memoryArr = new uint[](3);

// 内存中的固定数组

uint[3] memory fixedMemoryArr;

}

```

### 初始化

#### 直接初始化

```solidity

// 固定数组初始化

uint[3] public fixedArr = [1, 2, 3]; // 必须与声明的大小一致

// 动态数组初始化

uint[] public arr = [1, 2, 3]; // 动态数组，初始长度为3

// 在函数内部初始化内存数组

function foo() public pure {

// 使用字面量初始化内存数组（动态）

uint[] memory memoryArr = new uint[](3); // 初始化为0，然后可以赋值

memoryArr[0] = 1;

memoryArr[1] = 2;

memoryArr[2] = 3;

// 或者直接使用数组字面量（但要注意，数组字面量是固定大小的，需要显式转换为动态数组）

uint[] memory memoryArr2 = new uint[](3);

// 或者直接使用字面量创建固定大小数组，然后赋值给固定大小数组变量

uint[3] memory fixedArr = [1, 2, 3];

// 如果需要一个动态数组，可以创建一个固定数组然后将其赋值给动态数组（需要类型匹配，但固定数组不能直接赋值给动态数组）

// 因此，通常我们只能逐个赋值，或者使用循环。

}

```

#### 动态数组初始化

```solidity
function initDynamicArray() public {
    dynamicArray = new uint[](3); // 初始化全部为0
    dynamicArray[0] = 12; // 手动赋值
}
```

注意：在内存中，动态数组必须用`new`关键字创建，并指定初始长度。然后，我们可以通过索引为每个元素赋值。

## 3. 核心操作

### 访问数组元素

数组元素通过索引访问，索引从0开始。

```solidity

function getElement(uint index) public view returns (uint) {

require(index < arr.length, "Index out of bounds");

return arr[index];

}

uint x = getElement(2);

// 或者直接获取值
uint y = fixedArray[2];

```

### 修改元素

```solidity
fixedArray[1] = 100; // 修改固定数组
dynamicArray.push(200); // 动态数组追加元素（返回新长度）
```

### 删除元素

```solidity
delete dynamicArray[0]; // 重置为默认值（0），长度不变
dynamicArray.pop(); // 删除最后一个元素，长度减1
```

### 长度获取

数组有一个`length`属性，返回数组的长度。

```solidity

uint len = arr.length;

```

## 4. 数组的属性和方法

### push方法（仅动态数组）

动态数组有一个`push`方法，用于在数组末尾添加一个新元素，并返回新数组的长度（在较新版本中，`push()`返回引用，但通常我们使用它来添加元素）。

```solidity

function pushElement(uint value) public {

arr.push(value);

}

```

### pop方法（仅动态数组）

动态数组的`pop`方法用于删除数组的最后一个元素，同时数组长度减1。

```solidity

function popElement() public {

arr.pop();

}

```

## 5. 数组的遍历

可以使用`for`循环遍历数组。

```solidity

function sumArray() public view returns (uint) {

uint sum = 0;

for (uint i = 0; i < arr.length; i++) {

sum += arr[i];

}

return sum;

}

```

注意：在合约中，如果数组很大，遍历可能会消耗大量的gas，甚至超出区块gas limit，因此需要谨慎。

## 6. 数组作为函数参数

数组可以作为函数的参数，可以是内存数组或存储数组（存储数组需要指定为`storage`引用）。

```solidity

// 动态数组作为参数（内存数组）

function sum(uint[] memory data) public pure returns (uint) {

uint total = 0;

for (uint i = 0; i < data.length; i++) {

total += data[i];

}

return total;

}

// 存储数组的引用（可以修改原始存储）

function addToStorageArray(uint[] storage arr, uint value) internal {

arr.push(value);

}

function callAdd(uint value) public {

addToStorageArray(arr, value); // 这里arr是状态变量

}

```

## 7. 存储位置差异

### Storage（存储区）

```solidity
uint[] storage arrRef = dynamicArray; // 指向状态变量
arrRef[0] = 99; // 修改直接影响状态
```

### Memory（内存区）

```solidity
function processMemory() public pure {
    uint[] memory memArr = new uint[](3); // 内存中创建
    memArr[0] = 1; // 函数结束即销毁
}
```

## 8. 多维数组

### 声明与初始化

```solidity
uint[2][3] public matrix; // 3行2列固定数组

function initMatrix() public {
    matrix = [
        [1, 2],
        [3, 4],
        [5, 6]
    ];
}
```

### 访问二维数组的元素

```solidity

function getElement(uint i, uint j) public view returns (uint) {

require(i < twoDArray.length, "i out of bounds");

require(j < twoDArray[i].length, "j out of bounds");

return twoDArray[i][j];

}

```

## 9. 重要限制

- 边界检查：越界访问自动回滚（如 dynamicArray[100]）

- Gas 成本：

- - push/pop 消耗较多 Gas（存储修改）

- - 避免大型数组循环（可能超出 Gas 限制）

- 内存数组：

- - 必须预定义长度

- - 不支持 push/pop（仅存储区动态数组可用）

## 10. 最佳实践

### 预分配长度

减少 push 操作的 Gas 消耗

```solidity
uint[] arr;
function addItems(uint[] calldata data) public {
    uint start = arr.length;
    arr.length += data.length; // 预扩展长度
    for(uint i=0; i<data.length; i++){
        arr[start+i] = data[i]; // 直接赋值
    }
}
```

### 视图函数

用 view 函数读取数组避免 Gas 消耗

```solidity
function getArray() public view returns (uint[] memory) {
    return dynamicArray;
}
```

总结
特性 固定数组 动态数组（存储区）
声明 uint[5] arr; uint[] arr;
长度可变 ❌ ✅（push/pop）
内存中支持 ✅ ✅（但需固定长度）
初始化 编译时确定 运行时动态分配
Gas 效率 较高 push/pop 消耗较高

### 7. 注意事项

- **存储与内存**：在函数中，如果声明一个数组指向状态变量（存储数组），需要使用`storage`关键字，否则默认是`memory`（内存数组）。内存数组在函数执行结束后被销毁，而存储数组会持久化。

- **边界检查**：Solidity会自动检查数组索引是否在有效范围内（0到length-1），如果越界，会抛出异常。

- **Gas消耗**：对存储数组的写操作（尤其是改变数组长度的操作，如`push`和`pop`）会消耗较多的gas。读取操作相对便宜。

- **删除数组元素**：使用`delete`关键字可以删除数组元素，但这只是将元素重置为默认值（例如，uint重置为0），并不会改变数组长度（对于动态数组，如果想删除元素并减少长度，只能通过`pop`删除最后一个元素）。如果要删除中间元素，通常需要移动元素，这可能会很昂贵。

### 总结

Solidity中的数组是强大的数据结构，但使用时需要注意存储位置（storage或memory）以及操作的成本（gas消耗）。固定数组和动态数组有不同的用途，动态数组提供了更灵活的增删操作（但仅限于末尾操作）。在合约设计中，应尽量避免在链上存储大数据集，因为操作成本很高。
