# 结构体

在Solidity中，结构体（Struct）是一种自定义的复合数据类型，允许开发者将多个不同类型的变量组合在一个逻辑单元。结构体可以用来表示更复杂的数据结构，类似于其他编程语言中的类或结构。

## 基本概念

### 1. **定义结构体**

使用`struct`关键字定义一个结构体类型。内部可以包含多个不同类型的成员变量（可以是值类型、数组、映射或其他结构体）。

```solidity
struct User {
    address wallet;     // 地址类型
    string name;       // 字符串
    uint256 balance;   // 无符号整数
    bool isActive;     // 布尔值
}

```

### 2. **声明结构体变量**

可以声明结构体类型的变量，包括状态变量、局部变量，也可以用在映射和数组中。结构体可以通过构造函数或直接初始化成员来创建实例。

```solidity
// 状态变量
User public defaultUser;

// 函数内初始化（两种方式）
function createUser(address _wallet, string memory _name) public {
    // 方式1：按成员顺序初始化
    User memory newUser1 = User(_wallet, _name, 0, true);
    
    // 方式2：命名参数初始化（推荐，避免顺序错误）
    User memory newUser2 = User({
        wallet: _wallet,
        name: _name,
        balance: 0,
        isActive: true
    });
}
```

3. **访问结构体成员**：使用点号（`.`）来访问结构体的成员变量。

```solidity
function updateBalance(address _user, uint256_amount) public {
    defaultUser.balance += _amount; // 修改状态变量中的结构体成员
}
```

### 4. 在数组和映射中使用

结构体常与集合类型结合使用：

```solidity
User[] public users;                   // 结构体数组
mapping(address => User) public userMap; // 地址到结构体的映射

function addUser(address _wallet, string memory_name) public {
    users.push(User(_wallet,_name, 0, true)); // 添加到数组
    userMap[_wallet] = User(_wallet, _name, 0, true); // 添加到映射
}
```

### 5.存储位置（关键）

- storage:持久化存储在链上（修改会消耗Gas）
- memory: 临时内存，函数执行后会消失（适合只读操作）

```solidity
function updateUserName(uint256 _index, string memory _newName) public {
    // 从storage中加载结构体（直接修改原数据）
    User storage user = users[_index];
    user.name = _newName; // 修改会永久保存到区块链
}
```

---

### 示例

下面是一个简单的结构体使用示例：

```solidity

pragma solidity ^0.8.0;

contract StructExample {

// 定义一个结构体Person，包含两个成员：name和age

struct Person {

string name;

uint age;

}

// 创建一个Person结构体的状态变量

Person public myPerson;

// 创建一个存储多个Person的数组

Person[] public people;

// 创建一个映射，将地址与Person关联

mapping(address => Person) public addressToPerson;

// 函数：添加一个人到数组

function addPerson(string memory _name, uint _age) public {

// 方式1：按成员顺序初始化

people.push(Person(_name, _age));

// 方式2：使用命名成员初始化

people.push(Person({name: _name, age: _age}));

}

// 函数：设置myPerson

function setMyPerson(string memory _name, uint _age) public {

// 直接为结构体成员赋值

myPerson.name = _name;

myPerson.age = _age;

// 或者，使用一个结构体实例整体赋值

myPerson = Person(_name, _age);

}

// 函数：将调用者添加到映射

function addToMapping(string memory _name, uint _age) public {

addressToPerson[msg.sender] = Person(_name, _age);

}

// 函数：获取调用者在映射中的信息

function getPerson() public view returns (string memory, uint) {

// 从映射中获取结构体

Person memory p = addressToPerson[msg.sender];

return (p.name, p.age);

}

}

```

---

### 注意事项

1. **存储位置**：结构体可以存储在`storage`（永久存储在区块链上）或`memory`（临时存储，仅在函数调用期间存在）中。在函数内部处理结构体时，需要明确指定存储位置。

2. **初始化**：结构体初始化时，可以按照成员定义的顺序传入值，也可以使用成员名称进行指定（如示例中的命名初始化）。

3. **在数组和映射中的使用**：结构体可以作为数组的元素，也可以作为映射的值（但映射的键不能是结构体，因为结构体不是基本类型）。

4. **作为函数参数和返回值**：结构体可以作为函数的参数或返回值，但需要注意，声明为 public 的结构体状态变量，Solidity 会自动生成 getter 函数，但返回的是单个成员值（非完整结构体

5. **嵌套结构体**：结构体内部可以包含其他结构体，形成嵌套结构。但是不能直接包含自身（避免无限递归），但可通过映射间接实现树形结构

```solidity
struct Node {
    address parent;
    mapping(address => Node) children; // 允许嵌套
}
```

6. 构造函数限制

结构体没有构造函数，需手动初始化所有成员。

## 实际应用场景

### 用户账户管理

组合钱包地址、昵称、余额等数据。

### 游戏角色属性

存储角色的生命值、装备、技能等。

### 供应链追踪

记录产品的生产、运输状态（如 Product { string id; address manufacturer; uint256 timestamp; }）。

### 投票系统

封装投票者信息及投票权重。

### 示例：嵌套结构体

```solidity

pragma solidity ^0.8.0;

contract StructDemo {
    struct Product {
        uint256 id;
        string name;
        address owner;
        bool isShipped;
    }
    
    Product[] public products; // 产品数组
    
    // 添加新产品（memory临时使用）
    function addProduct(string memory _name) public {
        products.push(Product({
            id: products.length,
            name: _name,
            owner: msg.sender,
            isShipped: false
        }));
    }
    
    // 转移产品所有权（修改storage）
    function transferProduct(uint256 _id, address _newOwner) public {
        Product storage product = products[_id];
        require(product.owner == msg.sender, "Not owner");
        product.owner = _newOwner;
    }
}
```

## 最佳实践

最小化 storage 写入：批量更新成员变量，减少交易次数。

使用短类型：如 uint128 而非 uint256 可优化存储。

避免深层嵌套：复杂结构可能导致栈溢出（Solidity 调用栈深度限制为1024）。

通过合理使用结构体，可显著提升合约的可读性和数据管理效率，但需始终权衡链上存储成本与功能需求。

### 总结

结构体是Solidity中组织复杂数据的重要工具。通过结构体，你可以将多个相关数据项组合成一个逻辑单元，使代码更清晰、更易于管理。在使用结构体时，要特别注意数据存储位置（storage或memory）以及如何初始化。
