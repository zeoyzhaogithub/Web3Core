# 映射

## 定义

在Solidity中，映射（Mapping）是一种高效的存储键值对（key-value pairs）存储结构。可以理解为一个巨大的虚拟哈希表，其中包含了所有可能的键，每个键都被映射到一个默认值（例如，所有类型的零值），除非该键被显式地赋予了一个值。它在智能合约中广泛用于建立关联关系（如 address => uint 表示用户余额）。

## 核心特性

### 1. 键值对结构

```solidity

mapping(KeyType => ValueType) public myMapping;

```

- 示例：

```solidity

mapping(address => uint) public balances; // 地址到余额的映射
mapping(uint => string) public tokenNames; // 代币ID到名称的映射

```

这个映射将地址（`address`）映射到无符号整数（`uint`），可以用来记录每个地址的余额。

### 2. 键类型限制

- `KeyType`：可以是任何内置的值类型（如`uint`、`address`、`bytes`等）或合约类型。
- 不能是复杂类型（如另一个映射、结构体或数组）。

### 3. 值类型

- `ValueType`：可以是任何类型，包括映射、数组和结构体。

### 4.存储位置

- 映射必须声明为状态变量（存储在 Storage 中）。
- ❌ 不能在函数中作为局部变量使用。

### 关键规则

1. **没有长度/迭代概念**：映射没有长度，也没有键的集合或值的集合的概念，无法遍历所有键（需要额外维护键列表）。

2. **只能作为状态变量**：映射只能被声明为状态变量（在合约内部，但在函数外部）。它们也可以作为其他映射或数组的值类型（即嵌套映射），但不能在函数中作为局部变量使用。

3. **键的存储**：在映射中，键实际上并不存储；当需要访问某个键对应的值时，使用键的`keccak256`哈希来查找值。因此，映射不会记录键的存在，也无法遍历映射中的所有键。

4. **默认值机制**：当访问一个未设置的键时，会返回默认值（例如，`uint`类型的默认值是0，`address`的默认值是`0x0`，`bool`的默认值是`false`等）。

5. Gas 优化

读写操作消耗固定 Gas，与映射大小无关（哈希表实现）。

6. 删除操作

delete myMap[key] 将值重置为默认值（非移除键）。

## 嵌套映射

映射的值类型可以是另一个映射，形成嵌套映射。

例如：

```solidity

mapping(address => mapping(uint => bool)) public myNestedMapping;

```

使用：

```solidity

myNestedMapping[msg.sender][1] = true;

bool flag = myNestedMapping[msg.sender][1];

// 嵌套映射：地址 => (代币ID => 余额)
mapping(address => mapping(uint => uint)) public tokenBalances;

function setBalance(address user, uint tokenId, uint amount) public {
    tokenBalances[user][tokenId] = amount;
}
```

## 映射的使用场景

用户余额管理（address => uint）

代币元数据（uint tokenId => string URI）

权限控制（address => bool 白名单）

复杂关系（嵌套映射，如 address => (uint => bool)）

### 示例

```solidity

pragma solidity ^0.8.0;

contract MappingExample {

// 公共映射

mapping(address => uint) public balances;

// 更新余额

function updateBalance(uint newBalance) public {

balances[msg.sender] = newBalance;

}

// 获取余额（public映射会自动生成getter，所以不需要自己写，但这里为了演示也可以写一个）

function getBalance(address addr) public view returns (uint) {

return balances[addr];

}

// 重置余额

function resetBalance() public {

delete balances[msg.sender];

}

}

```

### 注意事项

1. **无法遍历**：由于映射的键没有存储，所以无法直接获取映射中所有的键或值。如果需要遍历，必须自行维护一个键的数组（并注意去重和删除的问题）。

2. **键的存储位置**：映射的键数据实际上存储在存储（storage）中，但键本身并不存储在映射里，而是通过哈希来定位值的位置。

3. **在函数中使用**：映射不能作为函数的参数或返回值（但公共映射会生成一个getter函数，可以访问单个键的值）。

4. **公共映射**：如果映射被声明为`public`，会自动生成一个getter函数，该函数接受一个键作为参数，返回对应的值。

5. 安全风险
未初始化键返回默认值可能导致逻辑错误（如误判余额为 0）。

## 映射与数组对比

特性 映射（Mapping） 数组（Array）
查找速度 O(1) 恒定时间 O(n) 线性扫描
内存开销 低（仅存实际数据） 高（需预留连续空间）
迭代支持 ❌ 不支持 ✅ 支持
键类型 复杂键（如 address） 整数索引

## 最佳实践

用映射处理快速键值查找。

需要迭代时，用数组单独存储键。

始终检查未初始化键的默认值陷阱（如 require(balances[user] > 0)）。

嵌套映射适合多层关系（如 ERC1155 多代币余额）。

### 总结

映射是Solidity中存储关联数据的高效方式，特别适合于根据键快速查找值的场景。但需要注意的是，映射无法遍历，因此在需要遍历键值对的情况下，需要结合数组等数据结构来使用。
