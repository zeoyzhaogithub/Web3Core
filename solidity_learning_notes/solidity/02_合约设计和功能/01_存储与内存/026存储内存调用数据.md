# 数据的位置

在 Solidity 中，数据的位置（data location）决定了变量的存储位置、生命周期和操作成本。它直接影响到变量的行为（如是否持久化）以及 Gas 消耗。主要的数据位置有三种：存储（storage）、内存（memory）和调用数据（calldata）。

-----

1. 数据位置：storage、memory和calldata
◦ storage：状态变量，可修改
◦ memory：临时存储，不保存在区块链上，可读写
◦ calldata：函数输⼊，不可修改，可⽤于节省 gas
2. 通过⽰例理解数据位置的应⽤：
◦ 使⽤struct从mapping中读取数据时，需指定数据位置
◦ 使⽤storage修改数据，使⽤memory读取数据
3. 函数参数和返回值的数据位置声明：
◦ 使⽤memory和calldata声明函数输⼊
◦ 使⽤memory声明函数返回值
4. 利⽤calldata节省 gas：
◦ 当将参数传递给另⼀个函数时，使⽤calldata可以避免数据复制，节省 gas

------

## 1. 存储（Storage）

### 定义

存储指的是区块链上永久存储数据的区域。每个合约都有自己的存储，它是状态变量存储的地方。数据`持久化`在链上，即在交易之间和函数调用之间数据都会被保存。

### 存储的布局

合约的存储是一个由2^256个32字节（256位）的槽（slot）组成的数组。每个槽都可以存储32字节的数据。状态变量在存储中的位置是按照它们声明的顺序从0开始依次分配的。但是，如果多个变量可以放在一个槽中（例如，多个小于32字节的变量），编译器会尝试将它们打包在一个槽中。

### 特点

- 持久化
存储中的数据会永久写入区块链状态树，即使交易结束也不会丢失。

- 高成本
读写成本高， （尤其是写入，Gas 成本非常高）。

- 存储是一个键值对（key-value）存储，其中键和值都是32字节的字。
- 状态变量
所有在合约顶层声明的变量（非函数内局部变量）默认存储在 Storage 中。
- 通过引用传递（赋值时共享底层数据）

- **使用场景**：状态变量默认存储在存储中。

- **示例**：

```solidity

contract StorageExample {
    uint[] public arr; // 默认存储在 storage

    function addToStorage(uint x) public {
        arr.push(x); // 直接修改 storage
    }
}

```

### 存储的使用方式

#### 1 直接操作状态变量（最常见）

```solidity
contract SimpleStorage {
    uint256 public data; // 存储在 slot0
    address owner;       // 存储在 slot1

    function setData(uint256 _data) external {
        data = _data; // 写入存储（高Gas消耗）
    }
}
```

#### 2.通过存储指针（Storage Pointers）

使用 storage 关键字创建指向已有状态变量的引用：

```solidity
contract PointerExample {
    struct User {
        uint id;
        string name;
    }
    User[] public users; // 动态数组，起始槽位按特定规则计算

    function updateUser(uint index, string calldata newName) external {
        // 创建指向存储的指针
        User storage user = users[index]; 
        user.name = newName; // 通过指针修改存储
    }
}
```

#### 3. 动态数组和映射的存储布局

- 动态数组
在声明槽位（如 slot0）存储数组长度，数据存储在 keccak256(0) 开始的地址。

- 映射
键 k 的值位置 = keccak256(h(k) . slot)，其中 slot 是映射的槽位，h 是键的哈希处理。

### 存储优化技巧

#### 变量打包（Packing）

将小于 32 字节的变量（如 uint8）连续声明，编译器会合并到同一槽位：

```solidity
uint8 a;  // slot0 (占用1字节)
uint16 b; // slot0 (占用2字节)
uint256 c; // slot1 (单独占用32字节)
```

#### 减少写入次数

批量更新状态变量，避免多次单独写入：

```solidity
// 低效：两次存储写入
function updateSeparately() external {
    a = 1;
    b = 2;
}

// 高效：一次存储写入（使用结构体）
struct Params { uint a; uint b; }
Params public params;
function updateTogether() external {
    params = Params(1, 2);
}
```

#### 使用内存缓存

复杂计算时先用 memory 变量处理，最后写回存储：

```solidity
uint[] public numbers;

function addNumbers(uint[] calldata newNumbers) external {
    // 在内存中操作（低Gas）
    uint[] memory cached = numbers;
    for (uint i; i < newNumbers.length; i++) {
        cached.push(newNumbers[i]);
    }
    // 一次性写回存储
    numbers = cached;
}
```

### 关键注意事项

安全风险
未经验证的存储写入可能导致漏洞（如重入攻击、权限绕过）。

槽位冲突
继承合约时，状态变量槽位按继承顺序排列，需谨慎设计。

初始化
存储变量默认初始化为 0，无需显式初始化。

Gas 估算
删除数据（delete var）可返还 Gas，但需权衡操作成本。

## 2. 内存（Memory）

### - **定义**

内存是临时的存储区域，仅在函数执行期间存在。当函数调用结束时，内存中的数据将被清除。

### - **特点**

- 读写成本低，读写速度比存储快（尤其是写入，适合临时操作）。

- **临时性**：仅在函数执行期间存在，函数执行完毕后，内存中的数据就会被清除。

4. **作用域**：通常用于函数内部，用于存储临时变量和复杂数据类型（如数组、结构体）的临时实例。

- 通过值传递（赋值时复制数据）
- 可变性 可修改（读写）
- 函数参数（非外部函数的引用类型参数除外）、函数内定义的引用类型局部变量通常需要使用`memory`关键字指定。

### 如何使用

- 当函数需要操作一个复杂数据类型（如数组、字符串、结构体）的临时副本时。

- 创建临时变量处理中间计算结果。

- 当函数返回一个复杂数据类型时，需要将结果存储在内存中以便返回。
- 读取 Storage 数据到临时副本进行操作（避免高成本修改 Storage）

- **示例**：

```solidity

contract MemoryExample {

   function sum(uint[] memory arr) public pure returns (uint) {

        uint total = 0;

        for (uint i = 0; i < arr.length; i++) {

            total += arr[i];
        }

        return total; // arr 是内存数组，函数结束后消失
    }
}

```

### **使用场景**

#### 函数参数/返回值

```solidity
// 输入内存数组，返回内存数组
function sum(uint[] memory inputs) public pure returns (uint[] memory) {
    uint[] memory result = new uint[](inputs.length);
    for (uint i=0; i<inputs.length; i++) {
        result[i] = inputs[i] * 2;
    }
    return result;
}
```

#### 2. 从 Storage 复制数据（避免直接修改）

```solidity
uint[] storageData; // 存储在区块链上

function safeUpdate() public {
    // 复制到内存中操作（低成本）
    uint[] memory temp = storageData;
    temp[0] = 100; // 修改内存副本

    // 需要显式写回 Storage 才能生效
    storageData = temp; 
}
```

#### 3. 字符串处理

```solidity
function merge(string memory a, string memory b) public pure returns (string memory) {
    return string(abi.encodePacked(a, b));
}
```

### 内存使用规则

固定大小：内存数组创建后长度不可变（不可 push/pop）。

复制行为：

- - memory → memory：引用传递（不复制数据）。

- - storage → memory：复制数据（创建独立副本）。

释放机制：无需手动释放，函数结束时自动回收。

## 3. 调用数据（Calldata）

### 定义

调用数据（calldata） 是存储函数参数的特殊数据区域，专为外部函数调用设计。它具有只读、非持久化、低成本的特性，是处理外部调用参数的推荐方式。

- **特点**：

- 只读性 调用数据是只读的，不能修改。

- Gas优化 比内存（memory）更节省Gas（因为不需要复制，直接使用原始调用数据）。
- 生命周期 仅在函数调用期间存在，调用结束后自动释放。
- 默认位置：通常用于外部函数（external）的参数（或公共函数的参数，当它们被外部调用时）。

### - **使用场景**

#### (1) 声明 calldata 参数

```solidity
// 显式声明参数为 calldata
function processData(uint[] calldata dataArray) external pure returns (uint) {
    return dataArray[0]; // 只读访问
}
```

#### (2) 避免内存复制（Gas 优化关键）

```solidity
// ✅ 推荐：直接使用 calldata 处理大型数据
function sumLargeArray(uint[] calldata data) external pure returns (uint) {
    uint total = 0;
    for (uint i = 0; i < data.length; i++) {
        total += data[i]; // 直接读取，无复制开销
    }
    return total;
}

// ❌ 低效：复制到 memory 消耗更多 Gas
function sumLargeArrayMemory(uint[] memory data) public pure returns (uint) {
    // 数据从 calldata 复制到 memory，消耗额外 Gas
    uint total = 0;
    for (uint i = 0; i < data.length; i++) {
        total += data[i];
    }
    return total;
}
```

#### (3) 与 abi.decode 配合解析数据

```solidity
function parseBytes(bytes calldata payload) external pure returns (address, uint) {
    // 直接解码 calldata 数据
    (address sender, uint amount) = abi.decode(payload, (address, uint));
    return (sender, amount);
}
```

### 3. 重要规则

仅限外部函数：calldata 只能用于 external 或 public 函数的参数（internal 函数需用 memory）。

引用类型专用：适用于数组、bytes、string、结构体等引用类型。值类型（如 uint）无需指定。

禁止修改：以下操作会引发错误：

```solidity
function invalidModify(uint[] calldata data) external pure {
    data[0] = 1; // ❌ 编译错误！calldata 不可修改
}
```

## 关键区别总结

|特性| Storage| Memory| Calldata|
|-----|--------|-------|---------|
|持久性| 永久存储（链上）| 临时（函数结束时销毁）| 临时（函数结束时销毁）|
|Gas 成本| 高（尤其是写入）| 低 |最低（只读）|
|可变性| 可读写| 可读写| 只读|
|传递方式| 引用传递（共享数据）| 值传递（复制数据）| 引用传递（原始数据）|
|适用场景| 状态变量| 函数内局部变量| 外部函数的参数|
|作用域 |合约状态| 函数内部| 函数参数|

---

## 如何使用

### 状态变量

默认在存储storage中，无需关键字

```solidity
uint public count; // 自动位于 storage
```

### 函数参数与局部变量

- 值类型（如`uint`，`bool`）的局部变量默认在内存中（但也可以显式指定为`memory`，不过通常不需要）。

- 引用类型（数组、结构体）的局部变量必须显式指定数据位置（`storage`、`memory`或`calldata`）。

- 外部函数的引用类型参数可以指定为`calldata`（推荐，因为节省Gas）。

- 公共函数和内部函数的引用类型参数可以指定为`memory`或`calldata`（公共函数如果可能被外部调用，则参数可以用`calldata`）。

```solidity
function process(
    uint[] memory inMemory, // 内存（可修改）
    uint[] calldata inCalldata // 调用数据（只读）
) external {
    uint[] storage s = arr; // 指向 storage 的引用
    uint[] memory m = new uint[](10); // 在内存中创建新数组
}
```

- 注意：外部函数的参数不能使用`memory`（外部函数引用类型参数只能使用`calldata`）。

### Gas 优化技巧

优先使用 calldata 替代 memory（避免复制数据）。

减少 storage 写入次数（批量更新状态变量）。

复杂计算在 memory 中完成，最后写回 storage。

### 注意事项

1. **赋值行为**：

- 将存储变量赋值给存储变量（通过引用）会创建新的独立副本吗？不会，默认情况下是引用赋值（即两个变量指向同一个存储位置）。如果要复制，必须显式复制（例如，对于数组，需要循环复制元素）。

- 将内存变量赋值给存储变量：会复制整个数据（从内存到存储，消耗大量Gas）。

- 将存储变量赋值给内存变量：会复制数据到内存。

### 示例对比

```solidity

contract DataLocations {

struct S { uint a; }

S[] public arr; // 存储在storage中

// 使用calldata参数（外部函数）

function example1(uint[] calldata data) external {

// 将calldata数据复制到内存（如果需要修改，则先复制到内存）

uint[] memory localData = data; // 复制整个数组到内存（此时可以修改localData，但原calldata不变）

// 操作存储数组

arr.push(S(localData[0])); // 从内存读取并写入存储（消耗Gas）

}

// 使用memory参数（内部函数或公共函数内部调用时）

function example2(uint[] memory data) public {

// 可以直接修改data（因为是内存数组）

data[0] = 1; // 修改内存数组

// 将内存数组复制到存储

arr.push(S(data[0]));

}

// 使用存储引用（避免复制）

function example3() public {

S storage s = arr[0]; // s是指向存储中arr[0]的引用

s.a = 5; // 直接修改存储中的值

}

}

```

### 总结

- **存储（Storage）**：持久化存储，用于状态变量，操作昂贵。

- **内存（Memory）**：临时存储，用于函数内的局部变量，操作相对便宜。

- **调用数据（Calldata）**：只读的临时存储，用于外部函数的参数，避免复制，节省Gas。

在编写合约时，合理选择数据位置可以显著优化Gas消耗。对于外部函数的引用类型参数，优先使用`calldata`；对于函数内部临时使用的引用类型变量，使用`memory`；而存储则用于需要持久保存的状态变量。
