# Proxy Admin - Transparent

Upgradeable Proxy - Part 5

2. 问题描述
• 当前问题：管理员调⽤代理合约中的admin或implementation函数时会冲突，因为这些函数在代
理合约和实现合约中都存在。
• 解决⽅案：创建Proxy Admin合约，管理代理合约的调⽤权限。
3. 编写Proxy Admin合约
• 定义合约和构造函数
◦ 创建Proxy Admin合约并设置所有者（合约的部署者）。
• onlyOwner修饰符
◦ 定义onlyOwner修饰符，确保只有所有者能执⾏某些函数。
• changeProxyAdmin函数
◦ 定义函数changeProxyAdmin，改变代理合约的管理员。
• upgrade函数
◦ 定义函数upgrade，升级代理合约中的实现合约。
4. 设置和调⽤函数
• 更改管理员
◦ 定义函数changeAdmin，更改代理合约的管理员。
• 静态调⽤函数
◦ 使⽤静态调⽤获取代理合约的管理员和实现合约地址（getProxyAdmin和
getProxyImplementation）。
5. 部署与测试
• 部署合约
◦ 部署CounterV1、CounterV2、Proxy和Proxy Admin合约。
• 测试合约
◦ 测试更改代理合约的管理员和实现合约地址。
◦ 测试CounterV1和CounterV2的功能，实现升级。

```solidity
1 // SPDX-License-Identifier: MIT
2 pragma solidity 0.8.23;
3
4
5 // 1. 重现透明可升级代理，并探讨其错误实现。
6 // 2. 视频系列内容：
7 // - 错误实现可升级代理合约,分析错误实现中的问题
8 // - 返回回退函数中的数据 fallback
9 // - 在智能合约的存储槽中写⼊任意数据
10 // - 存储实现合约地址和admin地址
11 // - 分离admin和user接⼝
12 // - proxy admin合约
13 // - 实际操作演⽰
14
15 contract CounterV1 {
16
17 uint256 public count;
18
19 function inc() external {
20 count += 1;
21 }
22
23 function admin() external view returns (address){
24 return address(1);
25 }
26
27 function implementation() external view returns(address){
28 return address(2);
29 }
30 }
31
32 contract CounterV2 {
33
34 uint256 public count;
35
36 function inc() external {
37 count += 1;
38 }
39
40 function dec() external {
41 count -= 1;
42 }
43 }
44
45 contract Proxy {
46 bytes32 private constant IMPLEMENTATION_SLOT =
bytes32(uint(keccak256("eip1967.proxy.implementation")) - 1);
47
48 bytes32 private constant ADMIN_SLOT =
bytes32(uint(keccak256("eip1967.proxy.admin")) - 1);
49
50
51 constructor() {
52_setAdmin(msg.sender);
53 }
54
55 function _delegate(address_implementation) private {
56 assembly {
57 // Copy msg.data. We take full control of memory in this inline
assembly
58 // block because it will not return to Solidity code. We overwrite
the
59 // Solidity scratch pad at memory position 0.
60
61 // calldatacopy(t, f, s) - copy s bytes from calldata at position
f to mem at position t
62 // calldatasize() - size of call data in bytes
63 calldatacopy(0, 0, calldatasize())
64
65 // Call the implementation.
66 // out and outsize are 0 because we don't know the size yet.
67
68 // delegatecall(g, a, in, insize, out, outsize) -
69 // - call contract at address a
70 // - with input mem[in…(in+insize))
71 // - providing g gas
72 // - and output area mem[out…(out+outsize))
73 // - returning 0 on error (eg. out of gas) and 1 on success
74 let result :=
75 delegatecall(gas(), _implementation, 0, calldatasize(), 0, 0)
76
77 // Copy the returned data.
78 // returndatacopy(t, f, s) - copy s bytes from returndata at
position f to mem at position t
79 // returndatasize() - size of the last returndata
80 returndatacopy(0, 0, returndatasize())
81
82 switch result
83 // delegatecall returns 0 on error.
84 case 0 {
85 // revert(p, s) - end execution, revert state changes, return
data mem[p…(p+s))
86 revert(0, returndatasize())
87 }
88 default {
89 // return(p, s) - end execution, return data mem[p…(p+s))
90 return(0, returndatasize())
91 }
92 }
93 }
94 function_fallback() private {
95 _delegate(_getImplementation());
96 }
97
98 fallback() external payable {
99 _fallback();
100 }
101
102 receive() external payable {
103_fallback();
104 }
105
106 modifier ifAdmin() {
107 if(msg.sender == _getAdmin()){
108_;
109 } else {
110 _fallback();
111 }
112 }
113
114 function changeAdmin(address_admin) external ifAdmin {
115 _setAdmin(_admin);
116 }
117
118 function upgradeTo(address _implementation) external ifAdmin {
119_setImplementation(_implementation);
120 }
121
122 function_getAdmin() private view returns(address) {
123 return StorageSlot.getAddressSlot(ADMIN_SLOT).value;
124 }
125
126 function_setAdmin(address _admin) private {
127 require(_admin != address(0), "admin = 0 address");
128 StorageSlot.getAddressSlot(ADMIN_SLOT).value =_admin;
129 }
130
131 function _getImplementation() private view returns(address) {
132 return StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value;
133 }
134
135 function _setImplementation(address_implementation) private {
136 require(_implementation.code.length > 0 , "not a contract");
137 StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value =
_implementation;
138 }
139
140 function admin() external ifAdmin returns (address){
141 return_getAdmin();
142 }
143
144 function implementation() external ifAdmin returns(address){
145 return _getImplementation();
146 }
147 }
148
149 contract ProxyAdmin {
150 address public owner;
151
152 constructor() {
153 owner = msg.sender;
154 }
155
156 modifier onlyOwner(){
157 require(msg.sender == owner, "not authorized");
158_;
159 }
160
161 function getProxyAdmin(address proxy) external view returns(address){
162 (bool ok, bytes memory res) = proxy.staticcall(
163 abi.encodeCall(Proxy.admin, ())
164 );
165 require(ok, "call failed");
166 return abi.decode(res, (address));
167 }
168
169 function getProxyImplementation(address proxy) external view
returns(address){
170 (bool ok, bytes memory res) = proxy.staticcall(
171 abi.encodeCall(Proxy.implementation, ())
172 );
173 require(ok, "call failed");
174 return abi.decode(res, (address));
175 }
176
177
178 function changeProxyAdmin(address payable proxy, address _admin)external
onlyOwner {
179 Proxy(proxy).changeAdmin(_admin);
180 }
181
182 function upgrade(address payable proxy, address implementation) external
onlyOwner {
183 Proxy(proxy).upgradeTo(implementation);
184 }
185 }
186
187
188 library StorageSlot {
189 struct AddressSlot {
190 address value;
191 }
192
193 function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot
storage r) {
194 assembly {
195 r.slot := slot
196 }
197 }
198 }
199
200 contract TestSlot {
201 bytes32 public constant SLOT = keccak256("TEST_SLOT");
202
203 function getSlot() external view returns (address) {
204 return StorageSlot.getAddressSlot(SLOT).value;
205 }
206
207 function writeSlot(address_addr) external {
208 StorageSlot.getAddressSlot(SLOT).value = _addr
}}
