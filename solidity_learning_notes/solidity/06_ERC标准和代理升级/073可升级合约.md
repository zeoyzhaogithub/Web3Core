# 可升级合约

Solidity 可升级合约详解

## 核心概念

可升级合约通过代理模式实现逻辑与数据分离：

- 代理合约（Proxy）：存储状态数据和逻辑合约地址
- 逻辑合约（Logic）：包含业务逻辑，可替换升级
- 委托调用（DelegateCall）：代理合约执行逻辑合约代码时保持自身存储上下文

## 关键功能说明

无状态冲突升级：保持存储布局兼容性

热替换逻辑：无需迁移数据即可更新合约

权限控制：仅管理员可执行升级

版本管理：支持多版本逻辑合约并存

紧急回滚：故障时可快速恢复旧版逻辑

## 实现步骤 & 具体流程

### 部署初始逻辑合约

```solidity
// LogicV1.sol
contract LogicV1 {
    uint public value;

    function initialize() external {
        value = 100; // 初始化状态
    }
    
    function setValue(uint _v) external {
        value = _v;
    }
}
```

### 部署代理合约

```solidity
// TransparentProxy.sol
contract TransparentProxy {
    address public implementation; // 逻辑合约地址
    address public admin;          // 管理员地址
    bytes32 private constant _IMPLEMENTATION_SLOT = 0x360894...;

    constructor(address _logic) {
        admin = msg.sender;
        _setImplementation(_logic);
    }

    function _setImplementation(address _newImplementation) private {
        assembly {
            sstore(_IMPLEMENTATION_SLOT, _newImplementation)
        }
    }
    
    // 委托调用入口
    fallback() external payable {
        address _impl = implementation;
        assembly {
            calldatacopy(0, 0, calldatasize())
            let result := delegatecall(gas(), _impl, 0, calldatasize(), 0, 0)
            returndatacopy(0, 0, returndatasize())
            switch result
            case 0 { revert(0, returndatasize()) }
            default { return(0, returndatasize()) }
        }
    }
}
```

### 初始化合约

```javascript
// Web3调用示例
await proxy.methods.initialize().send();
```

### 升级到新版本

```solidity
// LogicV2.sol (保持存储兼容)
contract LogicV2 {
    uint public value;         // 与V1相同的存储布局
    string public newFeature;  // 新增状态变量必须追加

    function migrate() external {
        newFeature = "Upgraded!";
    }
}
```

```javascript
// 升级操作
await proxy.methods.upgrade(newLogicAddress).send({from: admin});
```

### 数据迁移（可选）

```javascript
await proxy.methods.migrate().send();
```

## 完整基础可升级合约

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

// ===================== 逻辑合约 V1 =====================
contract LogicV1 {
    uint public value;
    bool private initialized;

    function initialize() external {
        require(!initialized, "Already initialized");
        initialized = true;
        value = 100;
    }
    
    function setValue(uint _v) external {
        value = _v;
    }
}

// ===================== 代理合约 =====================
contract TransparentProxy {
    address public implementation;
    address public admin;
    bytes32 private constant _IMPLEMENTATION_SLOT =
        0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;

    modifier onlyAdmin() {
        require(msg.sender == admin, "Admin only");
        _;
    }
    
    constructor(address _logic) {
        admin = msg.sender;
        _upgradeTo(_logic);
    }
    
    function upgradeTo(address _newImplementation) external onlyAdmin {
        _upgradeTo(_newImplementation);
    }
    
    function _upgradeTo(address _newImplementation) internal {
        require(_newImplementation != address(0), "Invalid address");
        implementation = _newImplementation;
        assembly {
            sstore(_IMPLEMENTATION_SLOT, _newImplementation)
        }
    }
    
    // 委托调用逻辑合约
    fallback() external payable {
        _delegate(implementation);
    }
    
    receive() external payable {}
    
    function _delegate(address _impl) internal {
        assembly {
            calldatacopy(0, 0, calldatasize())
            let result := delegatecall(gas(), _impl, 0, calldatasize(), 0, 0)
            returndatacopy(0, 0, returndatasize())
            switch result
            case 0 { revert(0, returndatasize()) }
            default { return(0, returndatasize()) }
        }
    }
}

// ===================== 逻辑合约 V2 =====================
contract LogicV2 {
    // 重要：必须保持原始存储布局
    uint public value;             // Slot 0
    bool private initialized;      // Slot 1
    string public newFeature;      // Slot 2 (新增)

    // 迁移函数（可选）
    function migrate() external {
        newFeature = "V2 Enabled!";
    }
    
    // 新增功能
    function increment() external {
        value += 10;
    }
}
```

## 升级操作流程

部署 LogicV1 合约

使用 V1 地址部署 TransparentProxy

通过代理调用 initialize() 初始化

部署 LogicV2 合约

调用代理的 upgradeTo(V2地址)

(可选) 调用 migrate() 迁移数据

## 核心注意事项

### 存储规则

逻辑合约必须保持状态变量顺序

新变量只能追加在末尾

禁止删除或修改现有变量

### 构造函数替代

使用 initialize 函数 + 初始化保护

防止重复初始化攻击

### 选择器冲突

使用透明代理模式（Transparent Proxy）

管理员调用直接执行，用户调用委托执行

### 安全建议

```solidity
// 推荐使用OpenZeppelin升级库
import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol";
```

## 生产环境建议

使用成熟的升级框架如 OpenZeppelin Upgrades Plugins，可自动处理存储冲突和安全验证。
