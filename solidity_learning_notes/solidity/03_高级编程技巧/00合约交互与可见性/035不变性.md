# 不变性（Immutability）

在 Solidity 中，不变性（Immutability） 是智能合约安全设计的核心原则之一，它确保某些状态在部署后无法被修改。Solidity 主要通过 immutable 和 constant 关键字实现不变性，两者有相似之处但也有重要区别。

## 1. 不可变量（immutable）

### 定义

使用 immutable 声明的变量只能在构造函数中初始化一次，之后永久不可修改。

### 特点

- 运行时赋值：值在部署合约时确定（例如通过构造函数参数）。

- 节省 Gas：读取 immutable 变量比读取普通状态变量更便宜（编译器会内联其值）。

- 存储位置：值不占用存储槽（Storage Slot），而是直接嵌入合约字节码。

### 适用场景

- 部署时确定的参数（如创建者地址、初始配置值）。

- 需要节省 Gas 的关键常量。

### 代码示例

```solidity
contract ImmutableExample {
    address public immutable owner;
    uint256 public immutable maxSupply;

    constructor(address _owner, uint256 _maxSupply) {
        owner = _owner;          // 只能在构造函数赋值
        maxSupply = _maxSupply;  // 赋值后永久不变
    }

    function tryChangeOwner() external {
        owner = msg.sender; // ❌ 编译错误！immutable 变量不可修改
    }
}
```

## 2. 常量（constant）

### 定义

使用 constant 声明的变量必须在编译时确定值，且必须是字面量或纯表达式。

### 特点

编译时赋值：值在代码编译时固定，无法使用构造函数参数或链上数据。

无 Gas 成本：读取 constant 变量无 Gas 消耗（值直接编译到字节码中）。

### 限制

仅支持值类型（如 uint, address）和 string/bytes。

值必须硬编码在合约中。

### 代码示例

```solidity
contract ConstantExample {
    uint256 public constant FEE_RATE = 10; // 编译时必须确定
    address public constant FEE_RECEIVER = 0x5B38Da6a701c568545dCfcB03FcB875f56beddC4;

    constructor() {
        // FEE_RATE = 20; ❌ 编译错误！constant 变量不可修改
    }
}
```

## 3. immutable vs constant 对比

|特性| immutable| constant|
|:---:|:---:|:---:|
|赋值时机| 构造函数（运行时）| 编译时|
|值来源| 构造函数参数/链上状态 |硬编码字面量|
|Gas 成本| 读取时低 Gas |读取时零 Gas|
|支持类型| 所有值类型 |值类型 + string/bytes|
|是否占用存储槽| ❌ 否| ❌ 否|

## 4. 最佳实践

### 优先使用 immutable

当值需在部署时动态确定（如合约创建者地址），使用 immutable。

```solidity
contract Token {
    address public immutable deployer;
    constructor() {
        deployer = msg.sender; // 动态赋值
    }
}
```

### 安全关键参数设为不可变

防止特权账户篡改核心参数：

```solidity
contract Vault {
    address public immutable beneficiary; // 受益人地址不可变
    constructor(address _beneficiary) {
        beneficiary =_beneficiary;
    }
}
```

### 优化 Gas 成本

高频访问的配置参数使用 immutable 或 constant 降低调用成本：

```solidity
contract Optimized {
    uint256 public immutable id; // 比普通状态变量读取更省 Gas
    constructor(uint256 _id) {
        id =_id;
    }
}
```

### 避免误用 constant

constant 仅适用于编译时已知的值：

```solidity
// ❌ 错误！block.number 是运行时值
uint256 public constant BLOCK_NUM = block.number;

// ✅ 正确
uint256 public constant MAX_UINT = type(uint256).max;
```

## 5. 常见误区

### 构造函数外赋值

immutable 变量仅在构造函数中可赋值，其他函数中修改会报错。

### 动态值用 constant

尝试将构造函数参数赋给 constant 会失败（编译时值未知）。

### 复杂类型限制

immutable 和 constant 均不支持结构体、映射等复杂类型。

## 总结

immutable：用于运行时一次性赋值的不可变变量（节省 Gas + 安全）。

constant：用于编译时确定的常量（零 Gas 读取 + 完全不可变）。

设计原则：将合约中不应修改的核心参数（如所有者、配置值）声明为不可变，是提升安全性和效率的关键手段。
