# 可见性(visibility)

在Solidity中，可见性（Visibility）用于控制合约中函数和状态变量可以被访问的范围。Solidity提供了四种可见性修饰符：`private`、`internal`、`public`和`external`。合理使用可见性修饰符是智能合约安全性的关键，他能防止未授权访问。

## 1. private（私有）

### 作用范围

仅在定义它们的当前合约内部可访问

### 特点

- 子合约无法继承

- 外部账户或其他合约无法访问

### 适用场景

存储敏感数据或内部逻辑（如密码哈希、临时计算值）。

### 示例

```solidity
contract Example {
    uint private secretData; // 私有状态变量

    function _internalCalculation() private pure returns (uint) {
        return 42; // 私有函数
    }
}
```

## 2. internal（内部）

### 作用范围

- 当前合约内部
- 继承该合约的子合约

### 特点

- 默认可见性（未指定时状态变量为 internal）
- 外部账户或其他合约无法访问

### 适用场景

需在继承体系中共享但对外隐藏的变量或函数。

### 示例

```solidity
contract Base {
    uint internal sharedValue; // 内部变量

    function _helper() internal pure returns (uint) {
        return 10; // 内部函数
    }
}

contract Child is Base {
    function useParent() public view returns (uint) {
        return sharedValue + _helper(); // 子合约可访问
    }
}
```

## 3. public（公开）

### 作用范围

- 当前合约内部
- 继承合约
- 外部账户或其他合约

### 特点

- 状态变量：自动生成同名 Getter 函数（如 myVar()）

- 函数：可通过交易或调用直接访问

### 适用场景

需要公开访问的接口或数据（如代币余额、公共方法）

```示例：

solidity
contract Token {
    mapping(address => uint) public balances; // 自动生成 balances(address) 函数

    function transfer() public { 
        // 可从外部调用
    }
}
```

## 4. external（外部）

### 作用范围

仅能从合约外部调用（其他合约/交易）

不能在当前合约内部直接访问（除非用 this.func()）

### 特点

调用时需通过合约地址（如 contract.func()）

函数参数通过 calldata 传递（节省 Gas）

### 适用场景

供外部调用的高效接口（避免内部调用开销）。

### 示例

```solidity
contract Math {
    function add(uint a, uint b) external pure returns (uint) {
        return a + b;
    }

    function internalCall() public {
        // add(1,2); // 错误！不能内部直接调用
        this.add(1,2); // 正确：通过 this 以外部方式调用
    }
}
```

## 关键对比表

|修饰符| 当前合约 |子合约| 外部调用| 状态变量| 函数|
|-|-|-|-|-|-|
|private| ✓ |✗ |✗| ✓ |✓|
|internal| ✓| ✓| ✗| ✓| ✓|
|public| ✓| ✓| ✓| ✓| ✓|
|external| ✗¹| ✗ |✓| ✗| ✓|

¹ external| 函数可通过 this.func() 在合约内部调用（视为外部调用）。

## 最佳实践

最小暴露原则：优先使用最严格的可见性（如先用 private，再按需放宽）。

状态变量：避免 public，必要时用 private + 自定义 Getter 函数控制访问。

外部接口：对高频调用的函数使用 external 优化 Gas。

安全审查：确保敏感操作（如资金转移）不为 public/external 除非必要。

通过合理应用可见性规则，可大幅提升合约的安全性和模块化程度

----

### 1. 状态变量的可见性

状态变量（即合约中定义的变量）可以有以下三种可见性：

- **`public`**：自动生成一个同名的getter函数，使得该变量可以在合约外部被读取。但是，在合约内部，直接使用变量名访问，而不是通过getter函数。

- **`internal`**：默认的可见性。状态变量只能在定义它们的合约以及继承合约中访问。外部无法访问。

- **`private`**：只能在定义它们的合约中访问，即使是继承合约也无法访问。

注意：状态变量不能设置为`external`。

### 2. 函数的可见性

函数可以使用所有四种可见性修饰符：

- **`private`**：只能在定义它们的合约内部访问，不能被继承合约访问。

- **`internal`**：默认的可见性（如果未指定）。可以在定义它们的合约以及继承合约中访问，但外部不可访问。

- **`public`**：可以在合约内部、继承合约以及合约外部访问。

- **`external`**：只能从合约外部访问（包括通过交易和调用）。在合约内部，不能直接访问（即不能通过`f()`调用），但可以通过`this.f()`来调用（此时是通过外部调用方式，会消耗更多gas）。

### 使用示例

#### 状态变量可见性示例

```solidity

contract VisibilityExample {

uint public publicVar = 1; // 自动生成getter函数，外部可读

uint internal internalVar = 2; // 内部和子合约可见

uint private privateVar = 3; // 仅当前合约可见

function getPrivateVar() public view returns (uint) {

return privateVar; // 在合约内部可以访问private变量

}

}

contract Child is VisibilityExample {

function getInternalVar() public view returns (uint) {

return internalVar; // 子合约可以访问internal变量

}

// 不能访问privateVar

}

```

#### 函数可见性示例

```solidity

contract FunctionVisibility {

// 私有函数：仅当前合约内部可调用

function privateFunc() private pure returns (string memory) {

return "private";

}

// 内部函数：当前合约和子合约可调用

function internalFunc() internal pure returns (string memory) {

return "internal";

}

// 公共函数：任何地方都可以调用

function publicFunc() public pure returns (string memory) {

return "public";

}

// 外部函数：只能从外部调用

function externalFunc() external pure returns (string memory) {

return "external";

}

// 在合约内部调用其他函数

function test() public view {

privateFunc(); // 可以

internalFunc(); // 可以

publicFunc(); // 可以

// externalFunc(); // 错误：不能在内部直接调用外部函数

this.externalFunc(); // 可以，但这是通过外部调用，会消耗更多gas

}

}

contract ChildFunction is FunctionVisibility {

function testChild() public view {

// privateFunc(); // 错误：不能访问父合约的私有函数

internalFunc(); // 可以

publicFunc(); // 可以

// externalFunc(); // 错误：不能内部调用外部函数，但可以通过外部调用方式

this.externalFunc(); // 可以

}

}

```

### 总结

- 使用`public`来暴露接口给外部和内部使用。

- 使用`external`来优化仅从外部调用的函数（因为外部函数在接收大量参数时，gas消耗可能更少），但注意在内部调用时需要特殊语法（`this.func()`）且会产生外部调用的开销。

- 使用`internal`来限制函数或状态变量在合约内部和子合约中使用。

- 使用`private`来完全隐藏实现细节，仅当前合约可用。

正确使用可见性修饰符有助于提高合约的安全性，避免不必要的访问。
