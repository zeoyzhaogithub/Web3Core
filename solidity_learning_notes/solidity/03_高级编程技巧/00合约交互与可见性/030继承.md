# 继承

在Solidity中，继承是一种允许一个合约（子合约）获取另一个合约（父合约）的属性和方法的机制。这有助于代码复用、逻辑分层和模块化设计。Solidity支持多重继承，即一个合约可以继承多个合约。

## 核心概念解析

### 基本语法

使用 is 关键字实现继承：

```solidity
contract Parent {
    // 父合约代码
}

contract Child is Parent {  // 继承Parent
    // 子合约代码
}
```

## 核心特性

### 函数重写（Override）

子合约可重写父合约的虚函数（标记 virtual），需使用 override：

```solidity
contract Parent {
    function foo() public virtual pure returns (string memory) {
        return "Parent";
    }
}

contract Child is Parent {
    function foo() public pure override returns (string memory) {
        return "Child"; // 重写父合约逻辑
    }
}
```

### 多重继承

Solidity 支持继承多个合约（逗号分隔）：

```solidity
contract A { function test() public virtual {} }
contract B { function test() public virtual {} }

contract C is A, B {
    function test() public override(A, B) {} // 显式声明重写来源
}
```

### 构造函数传参

父合约构造函数参数通过子合约传递：

```solidity
contract Parent {
    uint public value;
    constructor(uint _val) {
        value =_val;
    }
}

// 方式1：继承时直接传参
contract Child1 is Parent(100) {}

// 方式2：通过子合约构造函数传递
contract Child2 is Parent {
    constructor(uint _val) Parent(_val) {}
}
```

### 调用父合约函数

直接调用：ParentContract.functionName()

Super 关键字：super.functionName() 按继承顺序反向调用（从右到左）

```solidity

contract Parent {

    function foo() public virtual pure returns (string memory) {
        return "Parent";
    }

}

contract Middle is Parent {

    function foo() public virtual override pure returns (string memory) {
        return "Middle";
    }

}

contract Child is Middle {

    function foo() public override pure returns (string memory) {

        // 调用直接父合约Middle的foo函数
        string memory middleResult = Middle.foo();

        // 或者使用super，会调用Middle的foo
        string memory superResult = super.foo();

        return string.concat("Child calls: ", middleResult, " and ", superResult);
    }
}
```

## 关键规则与最佳实践

### 可见性限制

- public/internal 状态变量和函数可被继承

- private 成员仅限定义合约内部访问

- external 函数不可在内部调用（可通过 this.func() 调用）

### 线性化继承顺序

Solidity 使用 C3 线性化 解决多重继承冲突。声明顺序至关重要：

```solidity
contract Child is A, B, C { ... }
// 继承顺序：从最基础到最具体（C -> B -> A）
```

### 初始化顺序

构造函数执行顺序：从父到子（基类最先初始化）：

```text
Parent → Child → Grandchild
```

### 函数重写规范

父函数必须标记 virtual

子函数必须标记 override

多重继承需指定来源：override(A, B)

## 实战示例

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Ownable {
    address public owner;

    constructor() {
        owner = msg.sender;
    }

    modifier onlyOwner() virtual {
        require(msg.sender == owner, "Not owner");
        _;
    }
}

contract Pausable {
    bool public paused;

    function pause() public virtual {
        paused = true;
    }
}

contract MyContract is Ownable, Pausable {
    // 重写修饰符并扩展功能
    modifier onlyOwner() override {
        require(msg.sender == owner || msg.sender == address(0x1), "Denied");
        _;
    }

    // 重写并调用父合约函数
    function pause() public override onlyOwner {
        super.pause(); // 调用Pausable.pause()
        // 添加额外逻辑...
    }
}
```

## 使用场景

权限控制：继承 Ownable 实现所有权管理

功能模块化：如分离存储逻辑与业务逻辑

升级模式：通过代理合约继承实现可升级性

接口标准化：继承 ERC-20/ERC-721 等标准合约

## 常见错误防范

状态变量遮蔽：避免子合约声明与父合约同名的状态变量

构造函数顺序：确保父合约构造函数参数正确传递

重写冲突：多重继承时显式声明重写来源（override(A,B)）

可见性错误：重写函数的可见性必须与父函数一致

通过合理使用继承，可显著提升 Solidity 合约的安全性和可维护性，同时减少冗余代码。建议结合 OpenZeppelin 等标准库实践最佳模式。
