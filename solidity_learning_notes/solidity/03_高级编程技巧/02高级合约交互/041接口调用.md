# 接口调用

在 Solidity 中，接口（Interface） 是与其他合约交互的关键工具，它定义了合约对外暴露的函数签名（函数名、参数、返回值和可见性），但不包含具体实现。以下是接口调用的核心知识点和示例：

## 1. 接口定义规则

仅声明 external 函数（不能有 public/internal）

不能包含状态变量或构造函数

函数不能有实现（无函数体 {}）

可定义 event 和 error

支持继承其他接口

```solidity
interface IERC20 {
    function transfer(address to, uint amount) external returns (bool);
    event Transfer(address indexed from, address indexed to, uint value);
}
```

## 2. 接口调用步骤

### (1) 通过地址创建接口实例

```solidity
IERC20 token = IERC20(0xYourTokenAddress); // 传入目标合约地址
```

### (2) 调用接口函数

```solidity
// 发送 ETH（如果目标函数是 payable）
token.transfer{value: 1 ether}(msg.sender, 100);

// 不发送 ETH 的标准调用
bool success = token.transfer(msg.sender, 100);
require(success, "Transfer failed");
```

## 3. 完整调用示例

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface ICounter {
    function increment() external;
    function getCount() external view returns (uint);
}

contract Caller {
    ICounter public counter;

    // 初始化时绑定目标合约地址
    constructor(address _counterAddress) {
        counter = ICounter(_counterAddress);
    }

    // 调用接口函数
    function incrementCounter() external {
        counter.increment(); // 执行外部调用
    }

    // 读取状态
    function getCurrentCount() external view returns (uint) {
        return counter.getCount();
    }
}
```

## 4. 关键注意事项

### 安全检查

使用 require(success) 检查调用结果

高风险操作建议添加重入保护（如 OpenZeppelin 的 ReentrancyGuard）

### Gas 与支付

通过 {value: amount} 向 payable 函数发送 ETH

使用 gas 参数指定 Gas 上限：target.function{gas: 50000}(args)

### 错误处理

调用失败会触发 revert（自动回滚状态）

可通过 try/catch 捕获异常：

```solidity
try token.transfer(...) returns (bool success) {
    if (!success) revert("Transfer failed");
} catch Error(string memory reason) {
    // 处理 revert("reason")
} catch (bytes memory) {
    // 处理其他错误
}
```

### 地址验证

调用前检查地址是否为合约：

```solidity
require(_counterAddress.code.length > 0, "Not a contract");
```

## 5. 常见场景

代币操作：调用 ERC20/ERC721 的标准函数

DeFi 交互：与 Uniswap 等合约交换资产

跨合约通信：模块化合约间的函数调用

⚠️ 重要：始终假设外部调用可能失败或被恶意利用（如重入攻击），务必添加安全检查！
