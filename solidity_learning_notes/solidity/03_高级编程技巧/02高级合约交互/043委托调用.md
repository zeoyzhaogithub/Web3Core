# 委托调用（DelegateCall）

在 Solidity 中，委托调用（DelegateCall） 是一种特殊的底层函数调用方式，允许一个合约（调用者）执行另一个合约（目标）的代码，但使用调用者的存储上下文。这意味着目标合约的代码会读取和修改调用者合约的存储状态。这是实现可升级合约和代理模式的核心机制。

## 关键特性解析

### 存储上下文保留

- 当合约 A 通过 delegatecall 调用合约 B 的函数时：

- - 执行逻辑：合约 B 的代码逻辑。

- - 存储操作：所有存储读写发生在合约 A 的存储空间中。

- - 相当于将合约 B 的代码“注入”到合约 A 的上下文中执行。

### 环境变量行为

- msg.sender 和 msg.value 保持不变（仍是原始调用者）。

- address(this) 返回调用者合约（A）的地址，而非目标合约（B）。

### Gas 传递

所有 Gas 由调用者提供，目标合约的代码消耗调用者的 Gas。

## 代码示例

### 目标合约（Logic.sol）

```solidity
pragma solidity ^0.8.0;

contract Logic {
    uint public value; // 存储变量

    function setValue(uint _value) public {
        value = _value; // 修改的是调用者的存储！
    }
}
```

### 调用者合约（Caller.sol）

```solidity
pragma solidity ^0.8.0;

contract Caller {
    uint public value; // 存储布局必须与目标合约一致！
    address public logicContract;

    constructor(address _logicAddress) {
        logicContract = _logicAddress;
    }

    // 通过 delegatecall 执行目标合约的 setValue 函数
    function updateValue(uint _value) public {
        (bool success, ) = logicContract.delegatecall(
            abi.encodeWithSignature("setValue(uint256)", _value)
        );
        require(success, "Delegatecall failed");
    }
}
```

## 执行流程

部署 Logic 合约，获得地址 logicAddr。

部署 Caller 合约，传入 logicAddr。

调用 Caller.updateValue(100)：

- - 执行 Logic.setValue(100) 的代码逻辑。
- - 修改的是 Caller 合约的 value 变量（而非 Logic 的）。
- - Caller.value 被设置为 100。

## 核心应用场景

### 可升级合约（Proxy Pattern）

- 代理合约：持有状态数据，通过 delegatecall 将逻辑调用转发到逻辑合约。

- 逻辑合约：包含业务逻辑，可替换升级（只需更改代理指向的新逻辑合约地址）。

### 代码复用（库合约）

- 库合约通过 delegatecall 提供可复用函数（如 OpenZeppelin 库）。

- 示例：Address.sendValue() 通过 delegatecall 安全发送 ETH。

## 关键注意事项

### 存储布局兼容性

调用者与目标合约的存储变量顺序和类型必须严格一致，否则会导致存储冲突（严重漏洞！）。

### 函数选择器冲突

代理合约应避免定义与逻辑合约同名的函数（使用 fallback 转发所有调用）。

### 安全风险

目标合约的恶意代码可通过 selfdestruct 销毁调用者合约。

必须严格验证目标合约的地址和代码。

### Gas 管理

使用 staticcall 或明确指定 Gas 限制（如 delegatecall{gas: 1000000}(...)）防止 Gas 耗尽攻击。

## 与 call 的对比

|特性| call| delegatecall|
|:---:|:---:|:---:|
|存储上下文| 目标合约的存储| 调用者合约的存储
address(this)| 目标合约地址 |调用者合约地址
典型用途 |普通合约交互、转账 ETH |代理模式、库合约

## 最佳实践

使用 OpenZeppelin 的 TransparentUpgradeableProxy 或 UUPSProxy 实现安全代理。

通过 require(target.isContract()) 验证目标地址是否为合约。

在代理合约中使用以下转发模式：

```solidity
fallback() external payable {
    address impl = getImplementation(); // 获取当前逻辑合约地址
    (bool success, ) = impl.delegatecall(msg.data);
    require(success);
}

```

掌握 delegatecall 是理解以太坊高级架构（如可升级合约、模块化设计）的关键，务必谨慎处理存储布局和安全性！
