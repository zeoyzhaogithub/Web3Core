# 调用合约

在 Solidity 中调用其他合约主要有三种方式，每种方式适用于不同的场景。

## 1. 通过接口调用（推荐方式）

适用场景：已知目标合约的 ABI 和地址（最常见方式）

```solidity
// 步骤 1: 定义目标合约的接口（只需声明需要调用的函数）
interface ITargetContract {
    function targetFunction(uint param) external returns (uint);
}

contract Caller {
    // 步骤 2: 通过地址创建接口实例
    function callOtherContract(address _targetAddr) external returns (uint) {
        ITargetContract target = ITargetContract(_targetAddr);

        // 步骤 3: 直接调用函数（可处理返回值）
        uint result = target.targetFunction(123);
        
        // 可选：发送 ETH（如果目标函数是 payable）
        // target.targetFunction{value: 1 ether}(456);
        
        return result;
    }
}
```

## 2. 低级 call() 调用

适用场景：未知合约 ABI、动态调用、需要更精细控制

```solidity
contract Caller {
    function callWithLowLevel(address _targetAddr) external {
        // 编码函数调用数据（函数签名 + 参数）
        bytes memory payload = abi.encodeWithSignature(
            "targetFunction(uint256)",
            789
        );

        // 发起调用（处理 ETH 转账和错误）
        (bool success, bytes memory returnData) = _targetAddr.call{
            value: 0.5 ether  // 可选：发送 ETH
        }(payload);
        
        require(success, "Call failed!");
        
        // 解码返回值（需知道返回类型）
        uint result = abi.decode(returnData, (uint));
    }
}
```

## 3. 委托调用 (delegatecall)

适用场景：使用目标合约的代码但保留当前合约的存储和上下文

```solidity
contract Caller {
    uint public result;  // 结果将存储在当前合约中

    function delegateCall(address _targetAddr) external {
        bytes memory payload = abi.encodeWithSignature(
            "targetFunction(uint256)", 
            100
        );
        
        (bool success, ) = _targetAddr.delegatecall(payload);
        require(success, "Delegatecall failed!");
        // 目标函数修改的 storage 会作用于当前合约
    }
}
```

## 📌 关键注意事项

### 重入攻击防护

```solidity
// 使用 Checks-Effects-Interactions 模式
// 或 OpenZeppelin 的 ReentrancyGuard
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";

contract Caller is ReentrancyGuard {
    function safeCall(address target) external nonReentrant {
        ITarget(target).someFunction();
    }
}
```

### Gas 管理

```solidity
// 限制调用 gas
target.someFunction{gas: 50000}();
```

### 错误处理

```solidity
try target.someFunction() {
    // 成功逻辑
} catch Error(string memory reason) {
    // 处理 revert(reason)
} catch (bytes memory) {
    // 处理其它错误
}
```

### 合约存在性验证

```solidity
require(_targetAddr.code.length > 0, "Not a contract!");
```

## 完整调用流程

获取目标合约地址（可通过构造函数传入或预定义）

定义目标合约的接口（或使用低级 call）

处理可能的 ETH 转账（使用 {value: ...}）

调用函数并处理返回值

实施安全防护（防重入、gas 限制等）

## 根据具体场景选择调用方式

已知合约 ABI → 接口调用

动态调用未知合约 → call()

代码复用（如代理合约）→ delegatecall
