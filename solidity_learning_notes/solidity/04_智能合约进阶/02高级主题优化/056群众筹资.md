# 群众筹资（Crowdfunding）

## 概念

群众筹资（Crowdfunding）是一种通过智能合约实现的去中心化融资模式。项目发起人设定筹资目标和期限，支持者贡献资金。若在期限内达到目标金额，资金转给发起人；若未达到，支持者可申请退款。

## 核心功能

创建项目：发起人设置目标金额、截止时间。

捐款：支持者向项目发送ETH。

状态检查：自动判定项目成功/失败。

资金提取：成功时发起人提取资金。

退款：失败时支持者取回资金。

## 实现步骤与流程

### 1. 定义项目结构

```solidity
struct Project {
    address payable creator;  // 发起人地址
    uint goal;                // 目标金额（单位：wei）
    uint pledged;             // 已筹集金额
    uint deadline;            // 截止时间（Unix时间戳）
    bool claimed;             // 资金是否已被提取
    mapping(address => uint) pledges; // 支持者捐款记录
}
```

### 2. 状态变量

```solidity
Project[] public projects;   // 所有项目列表
```

### 3. 关键功能实现

#### 步骤1: 创建项目

```solidity
function createProject(uint _goal, uint_duration) external {
    uint deadline = block.timestamp + _duration;
    projects.push(Project({
        creator: payable(msg.sender),
        goal:_goal,
        pledged: 0,
        deadline: deadline,
        claimed: false
    }));
}
```

### 步骤2: 捐款

```solidity
function pledge(uint _projectId) external payable {
    Project storage project = projects[_projectId];
    require(block.timestamp < project.deadline, "Fundraising ended");

    project.pledges[msg.sender] += msg.value;
    project.pledged += msg.value;
}
```

### 步骤3: 检查项目状态

```solidity
function checkSuccess(uint _projectId) public view returns (bool) {
    Project storage project = projects[_projectId];
    return (project.pledged >= project.goal);
}
```

### 步骤4: 提取资金（发起人）

```solidity
function claimFunds(uint _projectId) external {
    Project storage project = projects[_projectId];
    require(block.timestamp >= project.deadline, "Not ended");
    require(checkSuccess(_projectId), "Goal not reached");
    require(!project.claimed, "Already claimed");

    project.claimed = true;
    project.creator.transfer(project.pledged);
}
```

### 步骤5: 退款（支持者）

```solidity
function refund(uint _projectId) external {
    Project storage project = projects[_projectId];
    require(block.timestamp >= project.deadline, "Not ended");
    require(!checkSuccess(_projectId), "Project succeeded");

    uint amount = project.pledges[msg.sender];
    require(amount > 0, "No pledge found");
    
    project.pledges[msg.sender] = 0;
    payable(msg.sender).transfer(amount);
}
```

## 完整合约代码

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Crowdfunding {
    struct Project {
        address payable creator;
        uint goal;
        uint pledged;
        uint deadline;
        bool claimed;
        mapping(address => uint) pledges;
    }

    Project[] public projects;

    event ProjectCreated(uint projectId, address creator, uint goal, uint deadline);
    event Pledged(uint projectId, address backer, uint amount);
    event FundsClaimed(uint projectId, uint amount);
    event Refunded(uint projectId, address backer, uint amount);

    // 创建新项目
    function createProject(uint _goal, uint _duration) external {
        uint deadline = block.timestamp + _duration;
        uint projectId = projects.length;
        
        Project storage newProject = projects.push();
        newProject.creator = payable(msg.sender);
        newProject.goal = _goal;
        newProject.deadline = deadline;
        
        emit ProjectCreated(projectId, msg.sender, _goal, deadline);
    }

    // 支持项目
    function pledge(uint _projectId) external payable {
        Project storage project = projects[_projectId];
        require(block.timestamp < project.deadline, "Fundraising ended");
        
        project.pledges[msg.sender] += msg.value;
        project.pledged += msg.value;
        emit Pledged(_projectId, msg.sender, msg.value);
    }

    // 检查项目是否成功
    function checkSuccess(uint _projectId) public view returns (bool) {
        Project storage project = projects[_projectId];
        return project.pledged >= project.goal;
    }

    // 发起人提取资金
    function claimFunds(uint _projectId) external {
        Project storage project = projects[_projectId];
        require(block.timestamp >= project.deadline, "Fundraising not ended");
        require(checkSuccess(_projectId), "Goal not reached");
        require(!project.claimed, "Funds already claimed");
        require(msg.sender == project.creator, "Unauthorized");
        
        project.claimed = true;
        project.creator.transfer(project.pledged);
        emit FundsClaimed(_projectId, project.pledged);
    }

    // 支持者退款
    function refund(uint _projectId) external {
        Project storage project = projects[_projectId];
        require(block.timestamp >= project.deadline, "Fundraising not ended");
        require(!checkSuccess(_projectId), "Project succeeded");
        
        uint amount = project.pledges[msg.sender];
        require(amount > 0, "No pledge to refund");
        
        project.pledges[msg.sender] = 0;
        payable(msg.sender).transfer(amount);
        emit Refunded(_projectId, msg.sender, amount);
    }

    // 查询支持者的捐款金额
    function getPledgeAmount(uint _projectId, address _backer) public view returns (uint) {
        return projects[_projectId].pledges[_backer];
    }
}
```

## 关键功能说明

### 防重入攻击

使用transfer()而非call()发送ETH，避免重入漏洞。

### 状态检查

checkSuccess()：验证项目是否达到目标。

所有操作需满足时间条件（block.timestamp校验）。

### 资金安全

失败时支持者自主退款（而非自动退回），避免Gas战争。

提取资金前标记claimed，防止重复提取。

### 数据透明

通过pledges映射记录每笔捐款。

提供getPledgeAmount()查询接口。

## 使用流程

### 创建项目

createProject(100 ether, 30 days)
（目标100 ETH，持续30天）

### 支持者捐款

pledge{value: 5 ether}(0)
（向项目ID=0捐款5 ETH）

### 项目结束

成功：发起人调用claimFunds(0)提取资金。

失败：支持者调用refund(0)取回资金。

此合约实现了去中心化筹资的核心逻辑，开发者可根据需求扩展功能（如多币种支持、里程碑提款等）。注意：在生产环境中需进行严格的安全审计。
