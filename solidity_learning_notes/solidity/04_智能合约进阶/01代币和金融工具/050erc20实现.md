# erc20 实现

以下是 ERC20 代币的完整 Solidity 实现，包含标准功能和安全最佳实践（基于 OpenZeppelin 风格）：

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract ERC20 {
    // 代币元数据
    string public name;
    string public symbol;
    uint8 public immutable decimals;
    uint256 public totalSupply;

    // 存储结构
    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;

    // 事件
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    // 错误类型
    error InsufficientBalance(uint256 available, uint256 required);
    error InsufficientAllowance(uint256 available, uint256 required);
    error ZeroAddress();

    constructor(
        string memory _name,
        string memory _symbol,
        uint8 _decimals,
        uint256 _initialSupply
    ) {
        name = _name;
        symbol = _symbol;
        decimals = _decimals;
        totalSupply = _initialSupply * 10 ** _decimals;
        _balances[msg.sender] = totalSupply;
        emit Transfer(address(0), msg.sender, totalSupply);
    }

    // 核心函数 ===============================================

    function balanceOf(address account) public view returns (uint256) {
        return _balances[account];
    }

    function transfer(address to, uint256 amount) public returns (bool) {
        _transfer(msg.sender, to, amount);
        return true;
    }

    function allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }

    function approve(address spender, uint256 amount) public returns (bool) {
        _approve(msg.sender, spender, amount);
        return true;
    }

    function transferFrom(
        address from,
        address to,
        uint256 amount
    ) public returns (bool) {
        _spendAllowance(from, msg.sender, amount);
        _transfer(from, to, amount);
        return true;
    }

    // 内部函数 ===============================================

    function _transfer(
        address from,
        address to,
        uint256 amount
    ) private {
        if (from == address(0)) revert ZeroAddress();
        if (to == address(0)) revert ZeroAddress();

        uint256 fromBalance = _balances[from];
        if (fromBalance < amount) {
            revert InsufficientBalance(fromBalance, amount);
        }
        
        unchecked {
            _balances[from] = fromBalance - amount;
            _balances[to] += amount;
        }

        emit Transfer(from, to, amount);
    }

    function _approve(
        address owner,
        address spender,
        uint256 amount
    ) private {
        if (owner == address(0)) revert ZeroAddress();
        if (spender == address(0)) revert ZeroAddress();

        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }

    function _spendAllowance(
        address owner,
        address spender,
        uint256 amount
    ) private {
        uint256 currentAllowance = allowance(owner, spender);
        if (currentAllowance < amount) {
            revert InsufficientAllowance(currentAllowance, amount);
        }
        unchecked {
            _approve(owner, spender, currentAllowance - amount);
        }
    }

    // 扩展功能（可选）=======================================
    
    // 增发代币（仅合约所有者）
    function mint(address account, uint256 amount) public {
        // 实际实现需要权限控制
        totalSupply += amount;
        _balances[account] += amount;
        emit Transfer(address(0), account, amount);
    }

    // 销毁代币
    function burn(uint256 amount) public {
        _burn(msg.sender, amount);
    }

    function _burn(address account, uint256 amount) private {
        if (_balances[account] < amount) {
            revert InsufficientBalance(_balances[account], amount);
        }
        unchecked {
            _balances[account] -= amount;
            totalSupply -= amount;
        }
        emit Transfer(account, address(0), amount);
    }
}
```

## 核心功能解析

### 基础结构

name/symbol/decimals：代币元数据

totalSupply：总发行量

_balances：地址余额映射

_allowances：授权额度映射

### 关键操作

transfer()：直接转账

approve()：授权第三方操作

transferFrom()：使用授权额度转账

balanceOf()/allowance()：状态查询

### 安全机制

使用 unchecked 块优化 Gas（Solidity 0.8+ 安全）

自定义错误类型（节省 Gas）

零地址检查

余额/授权额度不足检查

### 扩展功能

mint()：增发代币（需添加权限控制）

burn()：销毁代币

## 最佳实践建议

### 生产环境改进

```solidity
// 添加权限控制（使用 OpenZeppelin Ownable）
import "@openzeppelin/contracts/access/Ownable.sol";
contract MyToken is ERC20, Ownable {
    function mint(address to, uint256 amount) public onlyOwner {
        _mint(to, amount);
    }
}
```

使用 OpenZeppelin 实现

solidity
// 更安全的实现方式
import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
contract MyToken is ERC20 {
    constructor() ERC20("MyToken", "MTK") {
        _mint(msg.sender, 1000000 * 10**decimals());
    }
}

### 关键安全注意事项

使用最新 Solidity 版本（≥0.8.0）

对 decimals 使用 immutable 优化 Gas

外部调用前完成状态变更（防重入）

授权操作后需等待区块确认（前端需处理）

## 常见问题解答

Q: 为什么需要 transferFrom + approve 组合？
A: 实现第三方代理操作（如交易所提现、DEX 交易），无需私钥即可操作资金。

Q: decimals=18 有何意义？
A: 表示 1 个代币 = 10¹⁸ 最小单位（类似 1 ETH = 10¹⁸ wei），这是行业标准。

Q: 如何防止授权攻击？
A:

前端显示授权金额时使用 decimals

使用授权重置模式：

```solidity
// 先重置为0再设置新值
token.approve(spender, 0);
token.approve(spender, newAmount);
```

⚠️ 重要提示：生产环境建议直接使用 OpenZeppelin ERC20 实现，它包含安全审计和 Gas 优化实现。
