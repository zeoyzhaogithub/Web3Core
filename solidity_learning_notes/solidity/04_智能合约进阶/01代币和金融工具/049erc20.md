# erc20

在 Solidity 中，ERC20 是以太坊上最广泛使用的代币标准（Token Standard），它定义了一套规则和接口，使开发者能够创建可互操作的、兼容钱包/交易所的代币。以下是核心要点：

## 核心特性

### 标准化接口

所有 ERC20 代币都遵循相同的函数和事件命名，确保它们能与钱包（如 MetaMask）、交易所（如 Coinbase）和 DeFi 协议（如 Uniswap）无缝交互。

### 基本功能

代币转账（transfer）

余额查询（balanceOf）

授权其他地址使用代币（approve + transferFrom）

查询授权额度（allowance）

## 必选函数（6个）

```solidity
// 1. 获取代币总供应量
function totalSupply() external view returns (uint256);

// 2. 查询地址余额
function balanceOf(address account) external view returns (uint256);

// 3. 转账给他人
function transfer(address recipient, uint256 amount) external returns (bool);

// 4. 查询授权额度（A 允许 B 花多少代币）
function allowance(address owner, address spender) external view returns (uint256);

// 5. 授权他人使用自己的代币
function approve(address spender, uint256 amount) external returns (bool);

// 6. 代表他人转账（需提前授权）
function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
```

## 必选事件（2个）

```solidity
// 转账时触发
event Transfer(address indexed from, address indexed to, uint256 value);

// 授权时触发
event Approval(address indexed owner, address indexed spender, uint256 value);
```

## 可选字段（常用）

```solidity
string public name;     // 代币名称 (e.g., "My Token")
string public symbol;   // 代币符号 (e.g., "MTK")
uint8 public decimals;  // 小数位数 (e.g., 18，表示 1 代币 = 10¹⁸ 最小单位)
```

## 典型工作流

### 转账

```solidity
token.transfer(receiver, 100); // 直接转账
```

### 授权+代理转账

```solidity
token.approve(spender, 100);          // 授权给 spender
token.transferFrom(owner, receiver, 50); // spender 代理转账
```

## 重要性

互操作性：所有 ERC20 代币共享相同接口，可被统一支持。

生态兼容：交易所/钱包只需集成一次标准即可支持所有 ERC20 代币。

DeFi 基础：是借贷协议（Aave）、交易所（Uniswap）等的基础组件。

## 安全注意事项

重入攻击：旧版本 Solidity 需用 Checks-Effects-Interactions 模式防护。

授权风险：过度授权可能导致资产被盗（如授权后恶意合约转走代币）。

精度处理：计算时需考虑 decimals（如 1 ETH = 10¹⁸ wei）。

## 简单示例代码

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract MyToken {
    string public name = "MyToken";
    string public symbol = "MTK";
    uint8 public decimals = 18;
    uint256 public totalSupply = 1000000 * 10**uint256(decimals);

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor() {
        balanceOf[msg.sender] = totalSupply;
    }

    function transfer(address recipient, uint256 amount) external returns (bool) {
        require(balanceOf[msg.sender] >= amount, "Insufficient balance");
        balanceOf[msg.sender] -= amount;
        balanceOf[recipient] += amount;
        emit Transfer(msg.sender, recipient, amount);
        return true;
    }

    function approve(address spender, uint256 amount) external returns (bool) {
        allowance[msg.sender][spender] = amount;
        emit Approval(msg.sender, spender, amount);
        return true;
    }

    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool) {
        require(allowance[sender][msg.sender] >= amount, "Allowance exceeded");
        require(balanceOf[sender] >= amount, "Insufficient balance");
        allowance[sender][msg.sender] -= amount;
        balanceOf[sender] -= amount;
        balanceOf[recipient] += amount;
        emit Transfer(sender, recipient, amount);
        return true;
    }
}
```

📌 提示：实际开发推荐使用 OpenZeppelin 的标准 ERC20 实现，它经过充分审计并包含安全功能。

通过遵循 ERC20 标准，代币可无缝融入以太坊生态，成为 DeFi、NFT 等项目的基础设施。

# erc721和erc20是什么关系

在 Solidity 和以太坊生态中，ERC721 和 ERC20 是两种完全独立的代币标准，它们之间没有直接的继承或依赖关系。它们都是为了解决不同类型的问题而设计的，核心区别在于它们代表的资产的同质性。

以下是它们的关键区别和“关系”：

## 核心概念：资产性质

### ERC20：同质化代币 (Fungible Token)

每个代币都是完全相同且可以互换的。

就像现实世界中的法定货币（美元、欧元）或公司股票：你钱包里的 1 个 ETH 和我钱包里的 1 个 ETH 在价值和使用上是完全等同的，可以互相替换。关注的是数量。

### ERC721：非同质化代币 (Non-Fungible Token - NFT)

每个代币都是独一无二、不可分割且不可互换的。

就像现实世界中的收藏品（艺术品、房产证、独一无二的游戏道具）：每个代币都有其独特的标识符（Token ID）和属性（元数据）。一个 CryptoPunk 和另一个 CryptoPunk 是不同的资产，价值也各异。关注的是唯一标识符和属性。

## 接口方法 (关键区别)

### ERC20

balanceOf(address owner): 查询地址拥有的总量。

transfer(address to, uint256 value): 向地址转移一定数量的代币。

approve(address spender, uint256 value) / transferFrom(address from, address to, uint256 value): 允许另一个地址代表你转移一定数量的代币（常用于交易所、合约交互）。

核心操作围绕数值。

### ERC721

balanceOf(address owner): 查询地址拥有的 NFT 数量（不是总价值）。

ownerOf(uint256 tokenId): 查询特定 Token ID 的 NFT 的所有者是谁。

safeTransferFrom(address from, address to, uint256 tokenId)： 转移特定 Token ID 的 NFT 的所有权。

approve(address to, uint256 tokenId) / setApprovalForAll(address operator, bool approved): 允许另一个地址转移特定 NFT 或你拥有的所有 NFT。

核心操作围绕Token ID。

## 元数据

ERC20: 通常只有名称、符号、小数位（表示可分割性）。没有每个代币独立的元数据。

ERC721: 通过 tokenURI(uint256 tokenId) 函数指向一个 JSON 文件，该文件包含特定 Token ID 的元数据（如图片、视频、描述、属性等）。这是 NFT 独特性的关键支撑。

## 可分割性

ERC20: 通常是可分割的（例如，可以拥有 0.5 个代币），由 decimals 定义。

ERC721: 不可分割。一个 NFT 代表一个完整的、独一无二的资产单元。

## 总结它们的关系

### 平行关系

它们是兄弟标准，都由以太坊社区提出（EIP），并在智能合约层面通过接口定义了一套规则。它们都遵循 EIP 流程（EIP-20, EIP-721）。

### 互补关系

它们服务于不同的应用场景：

ERC20: 货币、实用代币、治理代币、稳定币、代表可互换资产的份额（如黄金、电力）。

ERC721: 数字收藏品、游戏内资产、虚拟土地、数字艺术品、身份证明、证书、门票、代表独一无二实物资产的凭证（如房产、奢侈品）。

### 基础概念共享

它们共享一些基础的区块链代币概念，如所有权记录在链上、可转移性、余额查询、授权机制（approve, transferFrom 的概念类似但参数不同）。

### 潜在交互

在实际应用中，它们可以结合使用

用 ERC20 代币（如稳定币 USDC）去购买 ERC721 NFT。

一个游戏可能使用 ERC20 作为游戏内货币，而 ERC721 代表独特的角色、装备或土地。

NFT 市场接受多种 ERC20 代币作为支付方式。

## 简单类比

ERC20 就像纸币： 你钱包里的 10 张 1 美元钞票和我钱包里的 10 张 1 美元钞票价值相同，可以互换。重要的是总金额（10 美元）。

ERC721 就像演唱会门票或艺术品： 每张票都有唯一的座位号（Token ID），不能互换（你的前排座位和我的后排座位价值不同）。每件艺术品都是原作，独一无二。重要的是具体的哪一张票或哪一幅画（Token ID 和其属性）。

因此，理解 ERC721 和 ERC20 的关键在于认识到它们分别代表 非同质化资产 和 同质化资产 的不同需求，它们是互补的、独立的标准，共同丰富了以太坊上的代币生态系统。
