# erc20

在 Solidity 中，ERC20 是以太坊上最广泛使用的代币标准（Token Standard），它定义了一套规则和接口，使开发者能够创建可互操作的、兼容钱包/交易所的代币。以下是核心要点：

## 核心特性

### 标准化接口

所有 ERC20 代币都遵循相同的函数和事件命名，确保它们能与钱包（如 MetaMask）、交易所（如 Coinbase）和 DeFi 协议（如 Uniswap）无缝交互。

### 基本功能

代币转账（transfer）

余额查询（balanceOf）

授权其他地址使用代币（approve + transferFrom）

查询授权额度（allowance）

## 必选函数（6个）

```solidity
// 1. 获取代币总供应量
function totalSupply() external view returns (uint256);

// 2. 查询地址余额
function balanceOf(address account) external view returns (uint256);

// 3. 转账给他人
function transfer(address recipient, uint256 amount) external returns (bool);

// 4. 查询授权额度（A 允许 B 花多少代币）
function allowance(address owner, address spender) external view returns (uint256);

// 5. 授权他人使用自己的代币
function approve(address spender, uint256 amount) external returns (bool);

// 6. 代表他人转账（需提前授权）
function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
```

## 必选事件（2个）

```solidity
// 转账时触发
event Transfer(address indexed from, address indexed to, uint256 value);

// 授权时触发
event Approval(address indexed owner, address indexed spender, uint256 value);
```

## 可选字段（常用）

```solidity
string public name;     // 代币名称 (e.g., "My Token")
string public symbol;   // 代币符号 (e.g., "MTK")
uint8 public decimals;  // 小数位数 (e.g., 18，表示 1 代币 = 10¹⁸ 最小单位)
```

## 典型工作流

### 转账

```solidity
token.transfer(receiver, 100); // 直接转账
```

### 授权+代理转账

```solidity
token.approve(spender, 100);          // 授权给 spender
token.transferFrom(owner, receiver, 50); // spender 代理转账
```

## 重要性

互操作性：所有 ERC20 代币共享相同接口，可被统一支持。

生态兼容：交易所/钱包只需集成一次标准即可支持所有 ERC20 代币。

DeFi 基础：是借贷协议（Aave）、交易所（Uniswap）等的基础组件。

## 安全注意事项

重入攻击：旧版本 Solidity 需用 Checks-Effects-Interactions 模式防护。

授权风险：过度授权可能导致资产被盗（如授权后恶意合约转走代币）。

精度处理：计算时需考虑 decimals（如 1 ETH = 10¹⁸ wei）。

## 简单示例代码

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract MyToken {
    string public name = "MyToken";
    string public symbol = "MTK";
    uint8 public decimals = 18;
    uint256 public totalSupply = 1000000 * 10**uint256(decimals);

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor() {
        balanceOf[msg.sender] = totalSupply;
    }

    function transfer(address recipient, uint256 amount) external returns (bool) {
        require(balanceOf[msg.sender] >= amount, "Insufficient balance");
        balanceOf[msg.sender] -= amount;
        balanceOf[recipient] += amount;
        emit Transfer(msg.sender, recipient, amount);
        return true;
    }

    function approve(address spender, uint256 amount) external returns (bool) {
        allowance[msg.sender][spender] = amount;
        emit Approval(msg.sender, spender, amount);
        return true;
    }

    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool) {
        require(allowance[sender][msg.sender] >= amount, "Allowance exceeded");
        require(balanceOf[sender] >= amount, "Insufficient balance");
        allowance[sender][msg.sender] -= amount;
        balanceOf[sender] -= amount;
        balanceOf[recipient] += amount;
        emit Transfer(sender, recipient, amount);
        return true;
    }
}
```

📌 提示：实际开发推荐使用 OpenZeppelin 的标准 ERC20 实现，它经过充分审计并包含安全功能。

通过遵循 ERC20 标准，代币可无缝融入以太坊生态，成为 DeFi、NFT 等项目的基础设施。
