# 全局变量

## 关键全局变量

◦ msg.sender ：调⽤函数的账⼾地址。
◦ block.timestamp ：调⽤函数时的UNIX时间戳。
◦ block.number ：当前的区块编号。
3. 创建和使⽤函数
介绍如何创建名为 globalVars 的外部函数，此函数⽤于访问和返回全局变量的值。
4. 函数类型： view 函数
解释 view 函数与其他类型（如 pure 函数）的区别，强调 view 函数可以读取状态变量和全局
变量的数据。

在 Solidity 中，全局变量是预定义的变量，提供了访问区块链和交易信息的途径。以下是主要的全局变量及其用法和示例：

---

### **1. 区块属性**

#### `blockhash(uint blockNumber) → bytes32`

获取指定区块的哈希（仅支持最近的256个区块）  

```solidity
bytes32 hash = blockhash(block.number - 1); // 上一个区块的哈希
```

#### `block.basefee (uint)`

当前区块的基础手续费（EIP-1559）  

```solidity
uint fee = block.basefee; // 如 1000000000 wei
```

#### `block.chainid (uint)`

当前链的ID  

```solidity
uint id = block.chainid; // 主网: 1, Goerli: 5
```

#### `block.coinbase (address payable)`

当前区块矿工/验证者的地址  

```solidity
address miner = block.coinbase;
```

#### `block.difficulty (uint)`

当前区块的 PoW 难度（PoS 链上含义不同）  

```solidity
uint diff = block.difficulty;
```

#### `block.gaslimit (uint)`

当前区块的 Gas 上限  

```solidity
uint limit = block.gaslimit; // 如 30000000
```

#### `block.number (uint)`

当前区块号  

```solidity
uint currentBlock = block.number; // 如 12345678
```

#### `block.timestamp (uint)`

当前区块的时间戳（Unix 秒）  

```solidity
uint time = block.timestamp; // 如 1625097600
```

---

### **2. 交易属性**

#### `msg.data (bytes calldata)`

完整的调用数据  

```solidity
bytes memory data = msg.data; // 如函数选择器+参数
```

#### `msg.sender (address)**

当前调用者的地址  

```solidity
function deposit() public payable {
    require(msg.sender != address(0), "Invalid sender");
    balances[msg.sender] += msg.value;
}
```

#### `msg.sig (bytes4)`

调用数据的前4字节（函数选择器）  

```solidity
bytes4 selector = msg.sig; // 如 0x6057361d
```

#### `msg.value (uint)**

交易附带的以太币数量（单位：wei）  

```solidity
function buyToken() public payable {
    require(msg.value == 1 ether, "Send exactly 1 ETH");
}
```

#### `tx.gasprice (uint)**

交易的 Gas 单价  

```solidity
uint gasPrice = tx.gasprice; // 如 20000000000 wei
```

#### `tx.origin (address)**

交易的原始发起者（完整调用链的起点）  

```solidity
address origin = tx.origin; // 警告：谨慎使用，有安全风险
```

---

### **3. 合约属性**

#### `address(this)`

当前合约的地址  

```solidity
function getContractAddress() public view returns (address) {
    return address(this); // 0x1234...5678
}
```

#### `this`

当前合约的引用（可转换为地址）  

```solidity
Contract c = this;
address addr = address(c);
```

---

### **4. 错误处理**

#### `assert(bool condition)`

检查内部错误（消耗所有 Gas）  

```solidity
function safeDiv(uint a, uint b) public pure returns (uint) {
    assert(b != 0); // 除零错误
    return a / b;
}
```

#### `require(bool condition)`

验证输入/条件（回滚并退还剩余 Gas）  

```solidity
function transfer(address to, uint amount) public {
    require(amount <= balances[msg.sender], "Insufficient balance");
    // 转账逻辑
}
```

#### `require(bool condition, string memory message)`

带错误信息的验证  

```solidity
require(msg.sender == owner, "Only owner can call");
```

#### `revert()`

立即终止执行  

```solidity
if (condition) revert();
```

#### `revert(string memory reason)`

终止执行并返回错误信息  

```solidity
revert("Operation failed");
```

---

### **5. 加密与编码**

#### `keccak256(bytes memory) → bytes32`

计算 Keccak-256 哈希  

```solidity
bytes32 hash = keccak256(abi.encodePacked("Hello")); // 0x1c8a...
```

#### `abi.encode(...) → bytes`

ABI 编码参数  

```solidity
bytes memory data = abi.encode(123, "abc"); // 用于函数调用
```

#### `abi.decode(bytes memory, (...))`

ABI 解码数据  

```solidity
(uint id, string memory name) = abi.decode(data, (uint, string));
```

---

### **6. Gas 操作**

#### `gasleft() → uint256`

获取剩余 Gas  

```solidity
uint startGas = gasleft();
// 执行操作
uint gasUsed = startGas - gasleft();
```

---

### **7. 其他重要变量**

#### `type(C).name (string)`

合约名称  

```solidity
string memory name = type(MyContract).name; // "MyContract"
```

#### `type(I).interfaceId (bytes4)**

接口标识符  

```solidity
bytes4 id = type(IERC721).interfaceId; // 用于 ERC165
```

---

### ⚠️ 使用注意事项

1. **`tx.origin` vs `msg.sender`**  
   - `msg.sender` 是直接调用者
   - `tx.origin` 是交易的原始发起者（可能被钓鱼攻击）

2. **时间戳风险**  
   `block.timestamp` 可被矿工轻微操纵，不适合精确计时。

3. **区块哈希限制**  
   `blockhash` 仅支持最近的 256 个区块。

4. **Gas 消耗**  
   `assert` 消耗所有 Gas，`require` 会退还剩余 Gas。

---

### 完整示例

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract GlobalVarsDemo {
    address public owner;
    uint public lastBlock;

    constructor() {
        owner = msg.sender;
        lastBlock = block.number;
    }

    function getInfo() public view returns (
        uint blockNum,
        uint timestamp,
        address sender,
        uint value
    ) {
        return (
            block.number,
            block.timestamp,
            msg.sender,
            msg.value
        );
    }

    function destroy() public {
        require(msg.sender == owner, "Not owner");
        selfdestruct(payable(owner));
    }
}
```

这些全局变量是 Solidity 开发的核心工具，合理使用它们可以构建安全高效的智能合约。
