# solidity中的函数分类

solidity中的函数主要可以从两个核心维度进行分类：

1. 状态的可变性（state mutability）：函数如何与区块链状态（存储变量）交互。
2. 可见性（Visibility）：函数可以被谁调用（外部账户、其他合约、自身合约、继承合约）

## 一、 状态的可变性（state mutability）分类

这个分类定义了函数是否能读取或修改合约的存储状态（永久存储在区块链上的变量）

### 1. view函数

1. 特征：

- 承诺不修改状态。这是核心特征
- 可以读取状态变量（存储变量）
- 可以调用其他`view`或`pure`函数
- 不能执行以下操作：修改状态变量、触发事件、创建其他合约、调用payable函数、使用selfdestruct、发送或者接收Ether(除了作为调用的一部分接收，但不会改变合约余额)、使用低级调用（除非是staticcall）、使用包含特定操作码的内联汇编。
- 在调用时（无论是从外部交易还是从另一个合约函数内部调用）**不消耗Gas**(当被外部账户通过EOA发起调用时，通常指在链下节点执行查询，或在只读调用如eth_call中)。

2. 使用场景

主要用于查询合约状态。例如获取用户的代币余额、获取合约配置、计算结果基于当前状态但不修改状态。

3. 声明
使用view关键字

4. 示例

```solidity
function getBalance(address _account) public view returns (uint256) {
    return balances[_account]; // 读取状态变量
}

function calculateInterest(uint256 principal) public view returns (uint256) {
    return principal * interestRate / 100; // interestRate 是状态变量
}
```

### 2. pure函数

1. 特征

- 承诺既不读取也不修改状态。这是最严格的限制。
- 只能访问函数的参数与局部变量。
- 可以调用其他pure函数。
- 不能执行view函数禁止的操作，同时也不能读取任何状态变量。
- 在调用时（无论是从外部交易还是从另一个合约函数内部调用）**不消耗Gas**(当被外部账户通过EOA发起调用时，通常指在链下节点执行查询，或在只读调用如eth_call中)。

2. 使用场景

用于使用纯计算，其输出仅依赖输入参数。例如数学计算（加法、哈希计算）、工具函数（格式化数据）、验证签名（仅基于提供的参数）。

3. 声明

使用pure关键字

4. 示例

```solidity
function add(uint256 a, uint256 b) public pure returns (uint256) {
    return a + b; // 仅使用参数
}

function keccak256Hash(bytes memory data) public pure returns (bytes32) {
    return keccak256(data); // 内置函数，纯计算
}
```

### 3. payable函数

1. 特征

- 核心功能是能够接收Ether。这是定义payable函数的主要原因。
- 可以修改状态（隐含了非view/pure的行为）
- 可以读取状态。
- 可以触发事件。
-可以调用其他函数（包括其他payable函数）
- 当被外部调用时，调用这必须能够发送Ether(通过交易设置value>0)。如果调用者发送了Ether,这些Ether会被存入合约的余额中。
- 消耗Gas。执行会改变状态，因此需要支付Gas。

2. 使用场景

所有需要接收Ether付款的操作。例如：购买代币、存入资金、参与拍卖、支付服务费。

3. 声明
使用payable 关键字。payable可以与可见性修饰符（如public payable）一起使用。

4. 示例

```solidity
function deposit() public payable {
    // msg.value 包含了发送的 Ether 数量
    balances[msg.sender] += msg.value;
    emit Deposited(msg.sender, msg.value); // 触发事件
}

function buyTokens() public payable {
    require(msg.value > 0, "Send ETH to buy tokens");
    uint256 tokensToBuy = msg.value * tokenPrice;
    _transferTokens(address(this), msg.sender, tokensToBuy); // 假设的内部转账函数
}
```

5. 重要

如果一个函数需要接收Ether，必须将其标记为payable。尝试向非payable函数发送Ether（value > 0）会导致交易被revert。

### 4. 非 view/pure/payable 函数 (默认)

1. 特征：

- 默认状态可变性。如果函数没有 view, pure, 或 payable 修饰符，它就属于这一类。

- 可以读取和修改状态。

- 可以触发事件。

- 可以调用其他函数（view, pure, 非 payable, payable）。

- 不能接收 Ether。 如果尝试向这类函数发送 Ether（value > 0），交易会被 revert。

- 消耗 Gas。 执行会改变状态，因此需要支付 Gas。

2. 使用场景：
需要修改合约状态但不需要接收 Ether 的操作。例如：更新用户信息、转移代币（ERC-20 transfer）、修改合约所有者、执行内部逻辑。

3. 声明：
无特定状态可变性关键字。

4. 示例：

```solidity
function setOwner(address _newOwner) public {
    require(msg.sender == owner, "Only owner can change owner");
    owner =_newOwner; // 修改状态变量
}

function transfer(address _to, uint256_amount) public {
    // ... 代币转账逻辑 (检查余额, 更新 balances[msg.sender] 和 balances[_to]) ...
}
```

## 二、 可见性（Visibility）

这个分类定义了函数可以在哪些上下文中被调用。

### 1. public

1. 特征：

- 最开放的可见性。

- 可以在以下位置调用：

- - 内部：同一合约内的其他函数中。

- - 外部：通过消息调用（由 EOA 或其他合约发起）。

- Solidity 会自动为 public 的状态变量生成一个同名的 public getter 函数。

2. 使用场景：
需要被合约内部逻辑和外部世界（用户、其他合约）访问的函数。通常是合约接口的主要组成部分。

3. 声明：
使用 public 关键字。

4. 示例：

```solidity
function approve(address _spender, uint256 _amount) public returns (bool) {
    allowances[msg.sender][_spender] =_amount;
    emit Approval(msg.sender, _spender,_amount);
    return true;
}
```

### 2. external

1. 特征：

- 设计用于外部调用。

- 可以在以下位置调用：

- - 外部：通过消息调用（由 EOA 或其他合约发起）必须使用 this.funcName() 语法。

- 不能在同一合约内直接通过函数名调用（例如 funcName()）。如果需要内部调用一个 external 函数，必须使用 this.funcName()，这实际上会发起一个外部调用（有 Gas 成本，且受限于 external 的规则）。

- 调用时参数传递效率可能略高于 public 函数（尤其是对于大型数组），因为数据直接从 calldata 读取，不需要复制到内存。

2. 使用场景：
明确只供外部使用的函数，且合约内部逻辑不需要直接调用它（或者可以接受通过 this. 调用带来的额外开销）。常用于合约的正式接口函数。

3. 声明：
使用 external 关键字。

4. 示例：

```solidity
// 这个函数只能由其他合约或交易调用
function transferFrom(address _from, address_to, uint256 _amount) external returns (bool) {
    // ... 逻辑 ...
}

function internalCaller() public {
    // 错误！不能直接调用 external 函数:
    // transferFrom(...);

    // 正确 (但开销大，是外部调用):
    this.transferFrom(...);
}
```

### 3. internal

1. 特征：

- 访问权限介于 public 和 private 之间。

- 可以在以下位置调用：

- - 内部：同一合约内的其他函数中。

- - 内部：继承该合约的派生合约内的函数中。

- 不能从外部（EOA 或其他不相关的合约）调用。

2. 使用场景：
实现合约的内部逻辑或可扩展的基合约功能，这些功能应该对继承者开放，但对公众隐藏。是默认的可见性（如果函数没有指定任何可见性修饰符，它就是 internal）。

3. 声明：
使用 internal 关键字。

4. 示例：

```solidity
// 基合约
contract Base {
    function _internalFunction() internal {
        // 内部逻辑，可被派生合约使用
    }
}

// 派生合约
contract Derived is Base {
    function callInternal() public {
        _internalFunction(); // 正确，可以调用继承的 internal 函数
    }
}
```

### 4. private

1. 特征：

- 最严格的可见性。

- 只能在同一合约（定义它的合约）内的其他函数中调用。

- 不能在继承的派生合约中调用。

- 不能从外部调用。

2. 使用场景：
实现合约严格私有的内部工具函数或状态修改逻辑，这些逻辑不应该被外部访问，也不应该被继承合约修改或依赖其实现细节。

3. 声明：
使用 private 关键字。

4. 示例：

```solidity
contract Vault {
    mapping(address => uint256) private secretBalances; // private 变量

    function _calculateFee(uint256 amount) private pure returns (uint256) {
        return amount / 100; // 私有工具函数
    }

    function deposit() public payable {
        uint256 fee = _calculateFee(msg.value);
        secretBalances[msg.sender] += msg.value - fee; // 访问 private 变量
    }
}
// 任何派生合约或外部调用都无法直接访问 `secretBalances` 或 `_calculateFee`

```

## 三、特殊函数

### 1. 构造函数 (constructor)

1. 特征：

- 一个在合约创建时（部署交易中）自动且仅执行一次的特殊函数。

- 用于初始化合约状态（设置所有者、初始化值等）。

- 可以是 public 或 internal 可见性（现代 Solidity 通常用 public 或省略，因为默认为 public）。不能是其他可见性。

- 在 Solidity 0.7.0 之前使用与合约同名的函数，现在必须使用 constructor 关键字。

- 如果是 internal，则合约被标记为 abstract。

2. 示例：

```solidity
contract MyContract {
    address owner;
    uint256 initialValue;

    constructor(uint256 _initValue) public {
        owner = msg.sender;
        initialValue = _initValue;
    }
}
```

### 2. 回退函数 (fallback)

1. 特征：

- 一个没有函数名、没有参数、没有返回值的特殊函数。

- 在以下情况被调用：

- - 调用合约时，没有匹配到任何函数签名。

- - 调用合约时附带发送了 Ether，但没有 receive 函数或 receive 函数不存在（在 Solidity >=0.6.0）。

- 必须标记为 external 可见性。

- 可以是 payable 或非 payable。如果需要接收任意发送的 Ether，它必须是 payable。

- 有 2300 Gas 的限制（在以太坊主网，其他链可能不同），因此能执行的操作非常有限（基本只能触发事件、记录日志或进行少量存储写入）。

2. 声明：
fallback () external [payable] { ... } 或 fallback (bytes calldata input) external [payable] returns (bytes memory output) { ... } (带数据版本)。

3. 示例：

```solidity
// 简单记录未知调用和接收的 ETH (必须 payable 才能接收)
fallback() external payable {
    emit Received(msg.sender, msg.value);
}

// 带数据版本的 fallback (更灵活，可以解析 input)
fallback(bytes calldata _input) external payable returns (bytes memory_output) {
    // 可以解析 _input 并返回_output
    emit ReceivedWithData(msg.sender, msg.value, _input);
    _output = abi.encode("Processed");
}
```

### 3. 接收 Ether 函数 (receive)

1. 特征：

- 一个专门用于接收纯 Ether 转账的特殊函数。

- 在调用合约时附带发送了 Ether (msg.value > 0) 且 calldata 为空（没有函数调用数据）时被调用。

- 必须标记为 external 可见性和 payable。

- 没有 function 关键字，没有参数，没有返回值。

- 同样有 2300 Gas 的限制。

- 比 fallback 函数优先级高（当 calldata 为空且有 Ether 发送时，优先调用 receive）。

2. 声明：
receive() external payable { ... }

3. 示例：

```solidity
// 简单接收 ETH 并记录
receive() external payable {
    emit Received(msg.sender, msg.value);
}
```

## 四、其他相关概念

- 函数修饰器 (modifier)： 虽然不是函数本身，但它们用于修改函数的行为（添加前置/后置条件检查，如权限检查 onlyOwner）。在函数声明中使用。

- 事件 (event)： 也不是函数，但函数内部可以触发事件来记录日志（这些日志存储在区块链上，可供外部监听）。使用 emit EventName(...) 触发。

- 错误 (error)： (Solidity 0.8.4+) 一种更高效、更清晰的方式来表示失败条件，与 revert 一起使用。替代了旧式的 require 中的字符串错误消息。

- require, assert, revert： 用于条件检查和错误处理的关键字/语句，通常在函数内部使用，会导致执行回滚 (revert)。

- 函数重载 (Function Overloading)： 允许在同一个合约内定义多个同名函数，只要它们的参数类型或数量不同。

- 接口 (interface)： 定义合约必须实现的函数签名（只有函数声明，没有实现）。用于合约间交互。接口中的函数默认是 external 的。

## 总结与最佳实践

1. 明确状态可变性： 始终为函数添加 view, pure, payable 或明确其为默认（可修改状态）的认知。这有助于编译器优化、用户理解 Gas 成本以及确保函数行为符合预期（特别是 payable 用于接收 ETH）。

2. 谨慎选择可见性： 应用最小权限原则。默认使用 internal 或 private 保护内部逻辑。仅将需要外部交互的函数暴露为 public 或 external。理解 public vs external 的细微差别（内部调用便利性 vs 外部调用效率）。

3. 安全处理 Ether：

- 明确标记需要接收 ETH 的函数为 payable。

- 仔细实现 receive 和 fallback 函数，理解它们的触发条件和 Gas 限制。如果合约不打算接收任意 ETH，考虑实现一个非 payable 的 fallback 函数来 revert。

- 在处理接收到的 ETH 时，使用 address(this).balance 时要小心重入风险（虽然 2300 Gas 限制大大降低了风险）。

4. 善用构造函数： 确保合约在部署时正确初始化所有必要的状态。

5. 使用修饰器： 将常见的检查（如权限控制）抽象成修饰器，提高代码复用性和可读性。

6. 优先使用自定义 error： 在 require/revert 中使用自定义错误类型比字符串错误信息更省 Gas。
