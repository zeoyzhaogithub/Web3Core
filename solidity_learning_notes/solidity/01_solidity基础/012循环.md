# 循环

在Solidity中，循环是控制流结构，允许我们重复执行一段代码，直到满足某个条件。Solidity支持`for`、`while`和`do...while`循环。然而，由于以太坊区块链的特性（尤其是Gas消耗和区块Gas限制），在智能合约中使用循环时需要格外小心，以避免消耗过多Gas甚至导致交易失败。

## 1. 循环类型

### a) for 循环

```solidity
for (uint i = 0; i < 10; i++) {
    // 执行逻辑
    values.push(i);
}
```

- 适用场景：已知迭代次数时（如固定长度数组）

- 风险：迭代次数过大时 Gas 消耗剧增

### b) while 循环

```solidity
uint count = 0;
while (count < users.length) {
    // 处理用户数据
    count++;
}
```

- 适用场景：迭代次数不确定时

- 危险：必须显式更新条件变量，否则导致无限循环

### c) do-while 循环

```solidity
uint i = 0;
do {
    // 至少执行一次
    i++;
} while (i < 5);
```

特点：先执行后检查条件

## 2. 关键风险与限制

- Gas 耗尽：每次循环迭代都消耗 Gas

- - 单区块 Gas 上限约 3000 万（以太坊）

- - 示例：1000 次存储写入 ≈ 消耗 2000 万 Gas

- 区块 Gas Limit：超过限制导致整个交易失败

- 无限循环：错误条件可能永久阻塞合约

## 3. 最佳实践与优化

### a) 避免长循环

```solidity
// 反模式：大数组循环
for(uint i; i < bigArray.length; i++) {
    _process(bigArray[i]); // 可能耗尽Gas
}

// 正解：分批次处理
uint constant BATCH_SIZE = 50;
function processBatch(uint startIndex) public {
    uint end = startIndex + BATCH_SIZE;
    if (end > bigArray.length) end = bigArray.length;

    for(uint i = startIndex; i < end; i++) {
        _process(bigArray[i]);
    }
}
```

### b) 使用映射替代数组

```solidity
// 反模式：循环查找
function findUser(address[] memory users, address target) internal pure returns (bool) {
    for(uint i; i < users.length; i++) {
        if(users[i] == target) return true;
    }
    return false;
}

// 正解：映射查找（O(1)复杂度）
mapping(address => bool) public isUser;
function checkUser(address target) public view returns (bool) {
    return isUser[target]; // 无循环
}
```

### c) 链下计算

- 复杂计算移至链下执行，仅将结果上链

- 使用 Oracle 或签名验证提交预计算结果

## 4. 特殊场景处理

### a) 删除数组元素

```solidity
// 安全删除（保持顺序）
function remove(uint index) public {
    require(index < arr.length);
    for (uint i = index; i < arr.length-1; i++) {
        arr[i] = arr[i+1]; // 移动元素
    }
    arr.pop(); // 删除末尾
}

// 高效删除（不保持顺序）
function fastRemove(uint index) public {
    arr[index] = arr[arr.length-1];
    arr.pop();
}
```

### b) 循环中的外部调用

```solidity
// 危险：可能引发重入攻击
for(uint i; i < users.length; i++) {
    users[i].transfer(1 ether); // 外部调用
}

// 安全模式：使用拉取支付（Pull Payment）
mapping(address => uint) public balances;
function withdraw() external {
    uint amount = balances[msg.sender];
    balances[msg.sender] = 0;
    payable(msg.sender).transfer(amount); // 由用户触发
}
```

## 5. Gas 优化技巧

- 缓存状态变量：减少 SLOAD 操作（每次 800 Gas）

```solidity
uint total = totalSupply; // 缓存到内存
for(uint i; i < 100; i++) {
    total += i;          // 使用内存变量
}
totalSupply = total;     // 最后写回存储
```

- 使用 unchecked (Solidity 0.8+)

```solidity
for(uint i; i < 10; ) {
    // 循环体...
    unchecked { i++; } // 跳过溢出检查，节省Gas
}
```

## 6. 设计模式替代方案

### a) 基于事件的流式处理

```solidity
event ItemProcessed(uint indexed id, address user);

function processItems(uint[] calldata ids) external {
    for(uint i; i < ids.length; i++) {
        _processSingle(ids[i]);
        emit ItemProcessed(ids[i], msg.sender); // 链下监听处理进度
    }
}
```

### b) 状态机模式

```solidity
enum State { Pending, Processing, Done }
struct Task {
    State state;
    uint currentStep;
}

function continueTask(uint taskId) external {
    Task storage task = tasks[taskId];
    require(task.state == State.Processing);

    _processStep(task.currentStep); // 每次调用处理一步
    task.currentStep++;
    
    if(task.currentStep >= TOTAL_STEPS) {
        task.state = State.Done;
    }
}

```

## 重要警告

### 永远不要信任外部输入控制循环次数

```solidity
// 高危！攻击者可传入超大数组耗尽Gas
function batchPay(address[] calldata receivers) external {
    for(uint i; i < receivers.length; i++) {
        payable(receivers[i]).transfer(1 ether);
    }
}
```

### 测试时模拟主网环境

- 使用 Hardhat/Foundry 进行 Gas 消耗测试

- 设置极限参数（如万级迭代）验证是否超限

## 结论

在 Solidity 中使用循环时：

优先考虑映射替代数组循环

超过 100 次迭代需设计分批次处理

循环内避免存储写入和外部调用

必须进行边界条件和 Gas 消耗测试

复杂逻辑尽量移至链下处理

通过结合状态机、事件驱动、拉取模式等设计，可显著降低智能合约因循环导致的失败风险。
