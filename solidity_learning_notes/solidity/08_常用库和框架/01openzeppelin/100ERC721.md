# ERC721

## 介绍

ERC721 是以太坊上用于创建 非同质化代币（NFT） 的智能合约标准。与 ERC20（同质化代币）不同，每个 ERC721 代币都是独一无二的，不可互换，适合代表独特资产（如艺术品、收藏品、虚拟地产等）。

## 核心功能

### 所有权管理

跟踪每个代币的唯一所有者。

### 代币转移

transferFrom()：所有者转移代币。

safeTransferFrom()：安全转移（检查接收方是否为合约且能否处理 NFT）。

### 授权机制

approve()：授权第三方操作单个代币。

setApprovalForAll()：授权第三方操作所有代币。

### 元数据支持

tokenURI()：获取代币元数据链接（JSON 文件，包含名称、描述、图像等）。

### 枚举扩展（可选）

查询总供应量、按索引获取代币等。

## 应用场景

### 数字艺术品

如 OpenSea、Rarible 上的加密艺术。

### 游戏资产

游戏道具、角色皮肤（如 Axie Infinity）。

### 收藏品

限量版卡片（如 NBA Top Shot）。

### 虚拟地产

Decentraland 中的土地。

### 身份认证

会员资格、域名（如 ENS）。

### 实物资产通证化

房产、奢侈品所有权证明。

## 如何使用（开发者角度）

### 步骤 1：安装依赖

```bash
npm install @openzeppelin/contracts
```

### 步骤 2：编写合约

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/utils/Counters.sol";

contract MyNFT is ERC721 {
    using Counters for Counters.Counter;
    Counters.Counter private _tokenIds;

    constructor() ERC721("MyNFT", "MNFT") {}

    // 铸造新 NFT
    function mintNFT(address recipient, string memory tokenURI) 
        public 
        returns (uint256) 
    {
        _tokenIds.increment();
        uint256 newTokenId = _tokenIds.current();
        _mint(recipient, newTokenId);
        _setTokenURI(newTokenId, tokenURI); // 需继承 ERC721URIStorage
        return newTokenId;
    }
}
```

### 步骤 3：部署合约

使用 Remix、Hardhat 或 Truffle 部署到以太坊网络（主网/测试网）。

### 步骤 4：用户交互

铸造：调用 mintNFT(用户地址, "ipfs://Qm...")。

转移：通过钱包调用 safeTransferFrom(发送方, 接收方, tokenId)。

查询：调用 ownerOf(tokenId) 或 tokenURI(tokenId)。

## 示例合约（完整版）

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol";
import "@openzeppelin/contracts/utils/Counters.sol";

contract ArtworkNFT is ERC721URIStorage {
    using Counters for Counters.Counter;
    Counters.Counter private _tokenIds;

    constructor() ERC721("ArtworkNFT", "ART") {}

    function mint(address to, string memory tokenURI) 
        public 
        returns (uint256) 
    {
        _tokenIds.increment();
        uint256 tokenId = _tokenIds.current();
        _mint(to, tokenId);
        _setTokenURI(tokenId, tokenURI);
        return tokenId;
    }

    // 重写 _baseURI 简化元数据路径
    function _baseURI() internal pure override returns (string memory) {
        return "ipfs://";
    }
}
```

## 注意事项

### 元数据存储

tokenURI 通常指向 IPFS/Arweave 的 JSON 文件（需永久存储）。

JSON 格式需符合 OpenSea 标准。

### Gas 优化

批量操作（如 mint 多个 NFT）可减少 Gas 消耗。

### 安全转移

优先使用 safeTransferFrom()，防止代币误转入无法处理的合约。

### 权限控制

添加 onlyOwner 修饰符限制铸造权限（避免滥用）。

### 合约升级

如需升级合约，使用代理模式（如 OpenZeppelin Upgradable）。

### 枚举扩展

若需支持批量查询，继承 ERC721Enumerable（注意 Gas 成本较高）。

### 跨链兼容性

跨链场景使用 Layer2（Polygon）或跨链桥（如 Wormhole）。

## 总结

ERC721 是 NFT 的基石标准，通过唯一性赋予数字资产稀缺性和所有权。开发时优先使用 OpenZeppelin 等审计库，注重元数据存储方案和 Gas 优化，同时确保合约权限与安全设计。

![](./WeChata0f6c0f23e95003841d44ea6ffc3b51b.jpg)
