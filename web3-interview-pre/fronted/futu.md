# 前端开发

## （二）面试题

### 1、平常有没有用node

### 2、

### 3、询问简历中的交易所项目，订单薄，高频渲染性能

k线图，长连接，短连接，懒加载，首屏加载

### 4、在 Web 性能监控时，你关注哪些指标？如何获取这些数据？

### 5、项目中说到用了 WebSocket 做断线重连加心跳检测。可以说一下这个具体是怎做什么吗？

### 6、编程题1：数组 A，B，实现一个方法，然后判断 A 是 B 的子集

```javascript
// 1. a,b 2个有序数组，a的长度小于等于b
// 2. 元素都是整数
// 3. 存在重复元素
// 实现一个方法，判断a是否为b的子集
// 例如：
// a: [1,2,3] b:[1,2,3,4] 属于
// a: [1,1,2,2] b[1,2,3,4] 不属于
// a: [1,3,3,5] b: [1,2,3,3,5,5] 属于
// a: [1,3,3,5] b: [1,3,5,5] 不属于
function isSubset(a, b) {
    if (a.length === 0) {
        return true;
    }
    // 检查数据
    for (const item of a) {
        if (!b.includes(item)) {
            return false;
        }
        // 删除重复元素
        b.splice(b.indexOf(item), 1);
    }
    return true;
}

let a = [1, 3, 3, 5];
let b = [1, 2, 3, 3, 5, 5];

// let a = [];
// let b = [1, 2, 3, 4];
// console.log(isSubset(a, b));
```

### 7、这个算法的时间复杂度是多少

设：

n = a.length
m = b.length

逐行分析：

b.includes(item)：需要遍历 b 查找，时间复杂度 O(m)
b.indexOf(item)：同样需要遍历 b 查找，时间复杂度 O(m)
b.splice(index, 1)：删除数组中间元素需要移动后续所有元素，时间复杂度 O(m)

对于 a 中的每个元素，这三步的总时间复杂度是 O(m + m + m) = O(3m) = O(m)

由于要对 a 中的每个元素执行上述操作，总时间复杂度为：O(n × m)

最坏情况
当 a 是 b 的子集时，需要处理 a 的所有元素，是最坏情况：

n = a.length
m = b.length

时间复杂度：O(n × m)

空间复杂度  只使用了常数级别的额外变量
空间复杂度：O(1)

### 8、算法中涉及到的b.includes的时间复杂度是多少

b.includes(item)：需要遍历 b 查找，时间复杂度 O(m)

### 9、编程题2：用递归的方式实现 fibonacci(n)函数， 斐波那契数列，为什么需要缓存

为什么需要缓存 - 核心原因
1)避免指数级重复计算
   无缓存：O(2^n) 时间复杂度
   有缓存：O(n) 时间复杂度

2)性能提升巨大
    计算 F(30)：
        无缓存：约 270万次函数调用
        有缓存：仅 31次函数调用

3)解决重叠子问题
    斐波那契数列是典型的重叠子问题结构
    大问题的解依赖于相同小问题的重复计算

缓存在这个算法中是必要的优化手段，它通过存储已计算结果，将算法从指数时间复杂度 O(2^n) 优化到线性时间复杂度 O(n)，解决了递归斐波那契数列的核心性能问题。

```javascript
// 输入数字 n，输出波菲那契数列第 n 项数字，并给该函数加 入缓存功能.

//     注:波菲那契数列是指第 0 项为 0，第一项为 1，第 n 项（n > 1）=第 n - 2 项 + 第 n - 1 项的数列
// 输入 输出
// 1 -- -> 1
// 2 -- -> 1
// 3 -- -> 2
// 4 -- -> 3
// 5 -- -> 5
// 6 -- -> 8

function fibonacci(n) {
    if (n < 2) {
        return n;
    }
    // 缓存
    const cache = {
        0: 0,
        1: 1
    }

    function calcFib(num) {
        // console.log(num)
        if (typeof num !== 'number' | num < 0 || !Number.isInteger(num)) {
            return '数据有误';
        }
        // 有缓存
        if (cache[num] !== undefined) {
            // console.log('有缓存--', cache[num]);
            return cache[num];
        }
        // 无缓存
        const result = calcFib(num - 1) + calcFib(num - 2);
        cache[num] = result;
        return result;
    }
    return calcFib(n);
}

console.log(fibonacci(6));
```

这是一个使用**记忆化（Memoization）**优化的斐波那契数列算法。

`算法逻辑分析`

1. 使用 `cache` 对象存储已计算的斐波那契数
2. 递归计算，但优先从缓存中取值
3. 每个斐波那契数只计算一次

`时间复杂度分析`

传统递归斐波那契（无记忆化）

- 时间复杂度：O(2^n) - 指数级
- 原因：存在大量重复计算

记忆化递归斐波那契（当前算法）

**关键点：** 每个斐波那契数 `F(n)` 只计算一次

设 `n` 为输入的参数：

1. **计算每个 F(k) 时：**
   - 检查缓存：O(1)
   - 如果没有缓存，递归计算 F(k-1) + F(k-2)
   - 存储结果到缓存：O(1)

2. **总计算量：**
   - 需要计算 F(0), F(1), F(2), ..., F(n)
   - 总共 n+1 个不同的斐波那契数
   - 每个数只计算一次

3. **时间复杂度：**
   - 每个斐波那契数的计算是 O(1) 操作（因为子问题结果已缓存）
   - 总共需要计算 n+1 个不同的值
   - **时间复杂度：O(n)**

空间复杂度分析

1. **缓存空间：** 存储 F(0) 到 F(n)，共 n+1 个值 → O(n)
2. **递归调用栈：** 最坏情况下深度为 n → O(n)
3. **总空间复杂度：O(n)**

- **时间复杂度：O(n)** - 线性时间
- **空间复杂度：O(n)** - 线性空间
- **优化效果：** 从指数级 O(2^n) 优化到线性级 O(n)

这是一个典型的**用空间换时间**的优化策略，通过记忆化技术避免了重复计算，大幅提升了算法效率。

### 10、http的状态码有知道哪些？

### 11、3开头的状态码有哪些？

301 moved permanently 永久重定向
核心含义：请求的资源永久迁移到了新地址，后续所有请求都应直接访问新地址。
典型场景：
网站域名更换（如 old.com 迁移到 new.com，访问 old.com/page 会 301 到 new.com/page）；
页面路径永久调整（如 /blog/old-title 改为 /blog/new-title）。
关键特性：浏览器会缓存新地址，下次再访问原地址时，会直接跳转到新地址（无需再发请求给服务器），适合 “永久变更” 的场景。
302 found 临时重定向
核心含义：请求的资源临时迁移到了新地址，后续请求仍需访问原地址（新地址可能随时变）。
典型场景：
临时维护页面（访问正常地址时，临时 302 到 /maintenance 页面，维护结束后恢复）；
登录跳转（未登录用户访问需权限的页面时，302 到登录页，登录成功后再跳回原页面）。
关键特性：浏览器不缓存新地址，每次访问原地址都会发请求给服务器，由服务器决定是否重定向，适合 “临时变更” 的场景。
304 Not Modified（未修改，协商缓存命中）
核心含义：请求的资源自上次获取后未发生变化，服务器无需返回资源内容，客户端直接使用本地缓存的资源即可。
典型场景：
静态资源（如 CSS、JS、图片）的缓存（客户端首次获取资源后，会记录 Last-Modified 或 ETag；下次请求时携带这些信息，服务器判断资源未变，返回 304，减少带宽消耗）；
频繁访问但很少更新的页面（如博客文章详情页）。
关键特性：这是 “性能优化核心状态码”，仅返回响应头（无响应体），大幅减少数据传输量，是前端静态资源缓存的核心机制之一。
12、4开头的状态码有哪些？
401 Unauthorized（未授权，登录态失效 / 未登录）
核心场景：你说的 “5 分钟后登录态失效，点击跳转” 就对应这个状态码。
比如数字资产平台，用户登录态过期后，点击 “查看我的资产”：
客户端发送请求时，携带的 Token 已过期（或没带 Token）；
服务器验证 Token 无效，返回 401 状态码；
前端收到 401 后，触发 “登录态失效” 逻辑（比如清空本地 Token，自动重定向到登录页）。
关键区别：401 是 “没证明身份”（比如没登录、Token 无效），解决方式是让用户重新登录。
2. 403 Forbidden（禁止访问，权限不足）
核心场景：用户已登录，但没有操作某资源的权限。
比如普通用户想访问数字资产平台的 “管理员后台”（/admin）：
用户登录后，携带有效 Token 请求 /admin；
服务器验证 Token 有效，但该用户角色是 “普通用户”，没有管理员权限，返回 403 状态码；
前端收到 403 后，通常显示 “无权限访问” 页面（而不是跳登录页，因为用户已登录，只是权限不够）。
和 401 区分：401 是 “没登录 / 登录态无效”，403 是 “已登录但没权限”。
3. 404 Not Found（资源未找到，地址错 / 资源删了）
最常见场景：用户访问的地址不存在（比如输错 URL、页面已删除）。
比如用户想访问数字资产的 “BTC-USDT 交易页”，但 URL 输成了 /trade/BTC-USD（多写了个 D）：
客户端请求 /trade/BTC-USD；
服务器找不到这个路径对应的资源，返回 404 状态码；
前端收到 404 后，显示 “页面不存在” 的 404 页面（比如引导用户返回首页）。
4. 400 Bad Request（请求参数错误，格式 / 内容不对）
核心场景：客户端发送的请求参数有问题（比如格式错、缺少必填项）。
比如用户在数字资产平台 “下单”，请求时没传 “交易数量”（必填参数）：
客户端发送下单请求，参数里少了 amount（数量）字段；
服务器校验参数时发现缺失必填项，返回 400 状态码，同时在响应体里说明错误（比如 {"error":"缺少必填参数：amount"}）；
前端收到 400 后，提示用户 “请填写交易数量”（不用跳页，直接在当前页显示错误）。
5. 408 Request Timeout（请求超时，客户端发送请求太慢）
核心场景：客户端发送请求后，服务器等了太久（比如超过 30 秒）还没收到完整的请求数据。
比如用户在网络极差的环境下，上传 “交易凭证图片”，数据传了一半卡住：
客户端开始上传图片，但网络中断，服务器长时间没收到完整数据；
服务器触发超时机制，返回 408 状态码；
前端收到 408 后，提示用户 “网络超时，请重试”（比如让用户重新上传图片）。
13、2开头的状态码
200 成功
14、http的缓存机制
强制缓存
协商缓存
15、http和https的区别？
加密，端口号：http是80，https是443；证书要求：http没有证书要求，Https必须在服务器端部署SSL证书
16、https的加密过程？
17、跨域？
18、同源策略？
19、有哪些方法可以解决跨域？
20、给你一个变量，怎么判断这个变量是不是数组？
21、Node 里面的那个ESM（ECMAScript Module，ES 模块）跟 com- CommonJS 有了解过吗？
22、常见的 web 安全吗？有哪些 web 安全是需要平常去注意的？
23、什么是 CSRF？
