# Solidity 中级面试题

本文为收集的 Solidity 相关中级职位的面试题和答案。

1. transfer 和 send 之间有什么区别？为什么不应该使用它们？

2. 如何在 Solidity 中编写高效的 gas 循环？

3. 代理合约中的存储冲突是什么？

4. 什么是闪电贷？

5. 在权益证明之前后，block.timestamp 发生了什么变化？

6. 什么是抢跑（frontrunning）？

7. 什么是提交-揭示方案，何时使用它？

8. 在什么情况下，abi.encodePacked 可能会产生漏洞？

9. 以太坊如何确定 EIP-1559[10] 中的 BASEFEE？

10. 冷读（cold read）和热读（warm read）之间有什么区别？

11. AMM 如何定价资产？

12. 代理中的函数选择器冲突是什么，它是如何发生的？

13. 什么是签名重放攻击？

14. 什么是 gas griefing(恶意破坏) ？

15. 如何设计一个石头-剪刀-布的智能合约游戏，使玩家无法作弊？

16. 自由内存指针是什么，它存储在哪里？

17. 接口中有效的函数修饰符有哪些？

18. 函数参数中的 memory 和 calldata 有什么区别？

19. 描述三种存储 gas 成本类型。

20. 为什么可升级合约不应该使用构造函数？

21. UUPS 和 Transparent Upgradeable Proxy 模式之间有什么区别？

22. 如果合约通过 delegatecall 调用一个空地址或之前已自毁的实现，会发生什么？如果是常规调用而不是 delegatecall 呢？

23. ERC777 代币存在什么危险？

24. 什么是债券曲线(bonding curve)？

25. OpenZeppelin ERC721 实现中的 safeMint 与 mint 有何不同？

26. 什么是三明治(sandwich)攻击？

27. 如果向一个会回滚的函数进行 delegatecall，delegatecall 会怎么做？

28. 乘以和除以二的倍数的 gas 高效替代方法是什么？

29. 多大 uint 可以与一个地址在一个槽中？

30. 哪些操作会部分退还 gas？

31. ERC165 作用于什么？

32. 如果代理对 A 进行 delegatecall，而 A 执行 address(this).balance，返回的是代理的余额还是 A 的余额？

33. 滑点参数有什么用？

34. ERC721A 如何减少铸造成本？有什么权衡？

35. 什么是 TWAP？

36. Compound Finance 如何计算利用率？

37. 为什么大量合约字节码以 6080604052 开头？这个字节码序列是做什么的？

38. 内存中的 bytes 和 bytes1[] 之间有什么区别？

39. 以太坊预编译合约的地址是什么？

40. uint64 和 uint256 在 calldata 中的 ABI 编码有何不同？

41. 为什么 calldata 中的负数会消耗更多的 gas？

参考答案

1. 为什么严格的不相等比较比 ≤ 或 ≥ 更节省 gas？额外的操作码是什么？
在 Solidity 中，使用严格的不相等比较（例如 != 或 ==）通常比使用 <= 或 ≥ 更节省 gas，因为 != 和 == 操作通常直接对应于单个 EVM 指令，如 EQ（等于）或 ISZERO（非零检查）。

相比之下，<= 或 ≥ 操作可能涉及多个步骤，如先比较（LT 或 GT）再取反（ISZERO）。因此，使用 != 或 == 可以减少执行的操作数，从而节省 gas。

提示：该问题考查以太坊 EVM 知识。

2. 为什么大量合约字节码以 6080604052 开头？这个字节码序列是做什么的？
字节码序列 6080604052 对应的 EVM Opcodes: PUSH1 0x80 PUSH1 0x40 MSTORE。

这段代码表示，向堆栈推入 0x40 和 0x80，然后执行 MSTORE 操作，它的两个操作数分别为 0x40 和 0x80。

整段代码等同于 MSTORE(0x40, 0x80)，也就是向内存中地址 0x40 处存储数据 0x80。

Solidity 内存空间预留了4 个 32 字节的插槽 slot，分别是：

0x00 起始的 64 字节: 哈希方法的暂存空间；

0x40 起始的 32 字节: 当前已分配内存大小，也称为空闲内存指针；

0x60 起始的 32 字节: 零槽，用作动态内存数组的初始值。

所以，MSTORE(0x40, 0x80)，用来设置空闲指针位置。

提示：该问题考查高级教程中的内联汇编知识。

3. 在权益证明之前后，block.timestamp 发生了什么变化？
在以太坊从工作量证明（PoW）过渡到权益证明（PoS）之前和之后，block.timestamp（区块时间戳）的基本机制并没有发生根本性变化。它仍然代表着区块被创建时的时间戳。

但在 PoS 中，由于区块生产更加规律且可预测，block.timestamp 的准确性和一致性可能会有所提高。

而在 PoW 中，出块时间可能受到挖矿难度和网络条件的较大影响，而在 PoS 中，这些因素的影响会减少。

提示：该问题考查以太坊共识算法的知识、基础教程中的全局变量。

12. 代理中的函数选择器冲突是什么，它是如何发生的？

函数选择器是函数签名的哈希的前四个字节。在 EVM 中，当一个函数被调用时，它是通过这个函数选择器来识别要执行的具体函数的。

在代理模式中，一个代理合约会将所有调用转发给另一个合约（实现合约）。如果代理合约和实现合约中存在具有相同函数选择器的函数，就会发生冲突，导致代理合约无法正确地将调用转发到预期的函数。

为了避免函数选择器冲突，开发者需要确保在代理合约和其实现合约中不会有具有相同选择器的不同函数。这通常意味着需要仔细地设计合约的接口，并在添加新方法时考虑潜在的冲突。

提示：该问题考查函数选择器 selector，可以参考高级教程中函数选择器 selector 。

28. 乘以和除以二的倍数的 gas 高效替代方法是什么？

在 Solidity 中，乘以或除以 2 的倍数可以用位运算符来实现，这是一种相对于标准乘法和除法更高效的方法。

具体来说，使用左移（<<）运算符来实现乘法，使用右移（>>）运算符来实现除法。

位运算比标准的算术运算更快，在 EVM 中，位运算的 Gas 成本通常低于乘法和除法运算。

提示：该问题考查初级教程中运算符的知识，以及高级教程中 Gas 优化知识。
